/* automatically generated by rust-bindgen */

pub type mystatus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_string_raw {
    pub data: *mut ::std::os::raw::c_char,
    pub size: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_mycore_string_raw() {
    assert_eq!(::std::mem::size_of::<mycore_string_raw>() , 24usize , concat !
               ( "Size of: " , stringify ! ( mycore_string_raw ) ));
    assert_eq! (::std::mem::align_of::<mycore_string_raw>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mycore_string_raw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string_raw ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string_raw ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string_raw ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string_raw ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string_raw ) ) . length as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string_raw ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for mycore_string_raw {
    fn clone(&self) -> Self { *self }
}
pub type mycore_string_raw_t = mycore_string_raw;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: usize,
    pub length: usize,
    pub mchar: *mut mchar_async_t,
    pub node_idx: usize,
}
#[test]
fn bindgen_test_layout_mycore_string() {
    assert_eq!(::std::mem::size_of::<mycore_string>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mycore_string ) ));
    assert_eq! (::std::mem::align_of::<mycore_string>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycore_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . length as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . mchar as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( mchar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . node_idx as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( node_idx ) ));
}
impl Clone for mycore_string {
    fn clone(&self) -> Self { *self }
}
pub type mycore_string_t = mycore_string;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_incoming_buffer {
    pub data: *const ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub offset: usize,
    pub prev: *mut mycore_incoming_buffer,
    pub next: *mut mycore_incoming_buffer,
}
#[test]
fn bindgen_test_layout_mycore_incoming_buffer() {
    assert_eq!(::std::mem::size_of::<mycore_incoming_buffer>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( mycore_incoming_buffer )
               ));
    assert_eq! (::std::mem::align_of::<mycore_incoming_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycore_incoming_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . prev as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . next as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( next ) ));
}
impl Clone for mycore_incoming_buffer {
    fn clone(&self) -> Self { *self }
}
pub type mycore_incoming_buffer_t = mycore_incoming_buffer;
pub type mycore_callback_serialize_f =
    ::std::option::Option<unsafe extern "C" fn(buffer:
                                                   *const ::std::os::raw::c_char,
                                               size: usize,
                                               ctx:
                                                   *mut ::std::os::raw::c_void)
                              -> mystatus_t>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcsync {
    pub spinlock: *mut ::std::os::raw::c_int,
    pub mutex: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mcsync() {
    assert_eq!(::std::mem::size_of::<mcsync>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mcsync ) ));
    assert_eq! (::std::mem::align_of::<mcsync>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcsync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . spinlock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( spinlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . mutex as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for mcsync {
    fn clone(&self) -> Self { *self }
}
pub type mcsync_t = mcsync;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_node {
    pub chunk: *mut mchar_async_chunk_t,
    pub cache: mchar_async_cache_t,
}
#[test]
fn bindgen_test_layout_mchar_async_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_node>() , 72usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_node ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mchar_async_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . chunk as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . cache as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( cache ) ));
}
impl Clone for mchar_async_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_node_t = mchar_async_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache_node {
    pub value: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub left: usize,
    pub right: usize,
    pub parent: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache_node>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( mchar_async_cache_node )
               ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache_node>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mchar_async_cache_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . left as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . right as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . parent as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( parent ) ));
}
impl Clone for mchar_async_cache_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_node_t = mchar_async_cache_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_chunk {
    pub begin: *mut ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub next: *mut mchar_async_chunk,
    pub prev: *mut mchar_async_chunk,
}
#[test]
fn bindgen_test_layout_mchar_async_chunk() {
    assert_eq!(::std::mem::size_of::<mchar_async_chunk>() , 40usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_chunk>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . begin as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . length as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . next as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . prev as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for mchar_async_chunk {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_chunk_t = mchar_async_chunk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache {
    pub nodes: *mut mchar_async_cache_node_t,
    pub nodes_size: usize,
    pub nodes_length: usize,
    pub nodes_root: usize,
    pub count: usize,
    pub index: *mut usize,
    pub index_length: usize,
    pub index_size: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache>() , 64usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_root as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . count as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_size ) ));
}
impl Clone for mchar_async_cache {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_t = mchar_async_cache;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async {
    pub origin_size: usize,
    pub chunks: *mut *mut mchar_async_chunk_t,
    pub chunks_pos_size: usize,
    pub chunks_pos_length: usize,
    pub chunks_size: usize,
    pub chunks_length: usize,
    pub chunk_cache: mchar_async_cache_t,
    pub nodes: *mut mchar_async_node_t,
    pub nodes_length: usize,
    pub nodes_size: usize,
    pub nodes_cache: *mut usize,
    pub nodes_cache_length: usize,
    pub nodes_cache_size: usize,
    pub mcsync: *mut mcsync_t,
}
#[test]
fn bindgen_test_layout_mchar_async() {
    assert_eq!(::std::mem::size_of::<mchar_async>() , 168usize , concat ! (
               "Size of: " , stringify ! ( mchar_async ) ));
    assert_eq! (::std::mem::align_of::<mchar_async>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mchar_async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . origin_size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( origin_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_length as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_length as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunk_cache as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunk_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_length as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_size as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_length as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_size as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . mcsync as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( mcsync ) ));
}
impl Clone for mchar_async {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_t = mchar_async;
pub const myencoding_list_MyENCODING_UTF_8: myencoding_list =
    myencoding_list::MyENCODING_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myencoding_list {
    MyENCODING_DEFAULT = 0,
    MyENCODING_NOT_DETERMINED = 2,
    MyENCODING_UTF_16LE = 4,
    MyENCODING_UTF_16BE = 5,
    MyENCODING_X_USER_DEFINED = 6,
    MyENCODING_BIG5 = 7,
    MyENCODING_EUC_JP = 8,
    MyENCODING_EUC_KR = 9,
    MyENCODING_GB18030 = 10,
    MyENCODING_GBK = 11,
    MyENCODING_IBM866 = 12,
    MyENCODING_ISO_2022_JP = 13,
    MyENCODING_ISO_8859_10 = 14,
    MyENCODING_ISO_8859_13 = 15,
    MyENCODING_ISO_8859_14 = 16,
    MyENCODING_ISO_8859_15 = 17,
    MyENCODING_ISO_8859_16 = 18,
    MyENCODING_ISO_8859_2 = 19,
    MyENCODING_ISO_8859_3 = 20,
    MyENCODING_ISO_8859_4 = 21,
    MyENCODING_ISO_8859_5 = 22,
    MyENCODING_ISO_8859_6 = 23,
    MyENCODING_ISO_8859_7 = 24,
    MyENCODING_ISO_8859_8 = 25,
    MyENCODING_ISO_8859_8_I = 26,
    MyENCODING_KOI8_R = 27,
    MyENCODING_KOI8_U = 28,
    MyENCODING_MACINTOSH = 29,
    MyENCODING_SHIFT_JIS = 30,
    MyENCODING_WINDOWS_1250 = 31,
    MyENCODING_WINDOWS_1251 = 32,
    MyENCODING_WINDOWS_1252 = 33,
    MyENCODING_WINDOWS_1253 = 34,
    MyENCODING_WINDOWS_1254 = 35,
    MyENCODING_WINDOWS_1255 = 36,
    MyENCODING_WINDOWS_1256 = 37,
    MyENCODING_WINDOWS_1257 = 38,
    MyENCODING_WINDOWS_1258 = 39,
    MyENCODING_WINDOWS_874 = 40,
    MyENCODING_X_MAC_CYRILLIC = 41,
    MyENCODING_LAST_ENTRY = 42,
}
pub use self::myencoding_list as myencoding_t;
pub const myhtml_tags_MyHTML_TAG_FIRST_ENTRY: myhtml_tags =
    myhtml_tags::MyHTML_TAG__TEXT;
#[repr(u32)]
/// @struct basic tag ids
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_tags {
    MyHTML_TAG__UNDEF = 0,
    MyHTML_TAG__TEXT = 1,
    MyHTML_TAG__COMMENT = 2,
    MyHTML_TAG__DOCTYPE = 3,
    MyHTML_TAG_A = 4,
    MyHTML_TAG_ABBR = 5,
    MyHTML_TAG_ACRONYM = 6,
    MyHTML_TAG_ADDRESS = 7,
    MyHTML_TAG_ANNOTATION_XML = 8,
    MyHTML_TAG_APPLET = 9,
    MyHTML_TAG_AREA = 10,
    MyHTML_TAG_ARTICLE = 11,
    MyHTML_TAG_ASIDE = 12,
    MyHTML_TAG_AUDIO = 13,
    MyHTML_TAG_B = 14,
    MyHTML_TAG_BASE = 15,
    MyHTML_TAG_BASEFONT = 16,
    MyHTML_TAG_BDI = 17,
    MyHTML_TAG_BDO = 18,
    MyHTML_TAG_BGSOUND = 19,
    MyHTML_TAG_BIG = 20,
    MyHTML_TAG_BLINK = 21,
    MyHTML_TAG_BLOCKQUOTE = 22,
    MyHTML_TAG_BODY = 23,
    MyHTML_TAG_BR = 24,
    MyHTML_TAG_BUTTON = 25,
    MyHTML_TAG_CANVAS = 26,
    MyHTML_TAG_CAPTION = 27,
    MyHTML_TAG_CENTER = 28,
    MyHTML_TAG_CITE = 29,
    MyHTML_TAG_CODE = 30,
    MyHTML_TAG_COL = 31,
    MyHTML_TAG_COLGROUP = 32,
    MyHTML_TAG_COMMAND = 33,
    MyHTML_TAG_COMMENT = 34,
    MyHTML_TAG_DATALIST = 35,
    MyHTML_TAG_DD = 36,
    MyHTML_TAG_DEL = 37,
    MyHTML_TAG_DETAILS = 38,
    MyHTML_TAG_DFN = 39,
    MyHTML_TAG_DIALOG = 40,
    MyHTML_TAG_DIR = 41,
    MyHTML_TAG_DIV = 42,
    MyHTML_TAG_DL = 43,
    MyHTML_TAG_DT = 44,
    MyHTML_TAG_EM = 45,
    MyHTML_TAG_EMBED = 46,
    MyHTML_TAG_FIELDSET = 47,
    MyHTML_TAG_FIGCAPTION = 48,
    MyHTML_TAG_FIGURE = 49,
    MyHTML_TAG_FONT = 50,
    MyHTML_TAG_FOOTER = 51,
    MyHTML_TAG_FORM = 52,
    MyHTML_TAG_FRAME = 53,
    MyHTML_TAG_FRAMESET = 54,
    MyHTML_TAG_H1 = 55,
    MyHTML_TAG_H2 = 56,
    MyHTML_TAG_H3 = 57,
    MyHTML_TAG_H4 = 58,
    MyHTML_TAG_H5 = 59,
    MyHTML_TAG_H6 = 60,
    MyHTML_TAG_HEAD = 61,
    MyHTML_TAG_HEADER = 62,
    MyHTML_TAG_HGROUP = 63,
    MyHTML_TAG_HR = 64,
    MyHTML_TAG_HTML = 65,
    MyHTML_TAG_I = 66,
    MyHTML_TAG_IFRAME = 67,
    MyHTML_TAG_IMAGE = 68,
    MyHTML_TAG_IMG = 69,
    MyHTML_TAG_INPUT = 70,
    MyHTML_TAG_INS = 71,
    MyHTML_TAG_ISINDEX = 72,
    MyHTML_TAG_KBD = 73,
    MyHTML_TAG_KEYGEN = 74,
    MyHTML_TAG_LABEL = 75,
    MyHTML_TAG_LEGEND = 76,
    MyHTML_TAG_LI = 77,
    MyHTML_TAG_LINK = 78,
    MyHTML_TAG_LISTING = 79,
    MyHTML_TAG_MAIN = 80,
    MyHTML_TAG_MAP = 81,
    MyHTML_TAG_MARK = 82,
    MyHTML_TAG_MARQUEE = 83,
    MyHTML_TAG_MENU = 84,
    MyHTML_TAG_MENUITEM = 85,
    MyHTML_TAG_META = 86,
    MyHTML_TAG_METER = 87,
    MyHTML_TAG_MTEXT = 88,
    MyHTML_TAG_NAV = 89,
    MyHTML_TAG_NOBR = 90,
    MyHTML_TAG_NOEMBED = 91,
    MyHTML_TAG_NOFRAMES = 92,
    MyHTML_TAG_NOSCRIPT = 93,
    MyHTML_TAG_OBJECT = 94,
    MyHTML_TAG_OL = 95,
    MyHTML_TAG_OPTGROUP = 96,
    MyHTML_TAG_OPTION = 97,
    MyHTML_TAG_OUTPUT = 98,
    MyHTML_TAG_P = 99,
    MyHTML_TAG_PARAM = 100,
    MyHTML_TAG_PLAINTEXT = 101,
    MyHTML_TAG_PRE = 102,
    MyHTML_TAG_PROGRESS = 103,
    MyHTML_TAG_Q = 104,
    MyHTML_TAG_RB = 105,
    MyHTML_TAG_RP = 106,
    MyHTML_TAG_RT = 107,
    MyHTML_TAG_RTC = 108,
    MyHTML_TAG_RUBY = 109,
    MyHTML_TAG_S = 110,
    MyHTML_TAG_SAMP = 111,
    MyHTML_TAG_SCRIPT = 112,
    MyHTML_TAG_SECTION = 113,
    MyHTML_TAG_SELECT = 114,
    MyHTML_TAG_SMALL = 115,
    MyHTML_TAG_SOURCE = 116,
    MyHTML_TAG_SPAN = 117,
    MyHTML_TAG_STRIKE = 118,
    MyHTML_TAG_STRONG = 119,
    MyHTML_TAG_STYLE = 120,
    MyHTML_TAG_SUB = 121,
    MyHTML_TAG_SUMMARY = 122,
    MyHTML_TAG_SUP = 123,
    MyHTML_TAG_SVG = 124,
    MyHTML_TAG_TABLE = 125,
    MyHTML_TAG_TBODY = 126,
    MyHTML_TAG_TD = 127,
    MyHTML_TAG_TEMPLATE = 128,
    MyHTML_TAG_TEXTAREA = 129,
    MyHTML_TAG_TFOOT = 130,
    MyHTML_TAG_TH = 131,
    MyHTML_TAG_THEAD = 132,
    MyHTML_TAG_TIME = 133,
    MyHTML_TAG_TITLE = 134,
    MyHTML_TAG_TR = 135,
    MyHTML_TAG_TRACK = 136,
    MyHTML_TAG_TT = 137,
    MyHTML_TAG_U = 138,
    MyHTML_TAG_UL = 139,
    MyHTML_TAG_VAR = 140,
    MyHTML_TAG_VIDEO = 141,
    MyHTML_TAG_WBR = 142,
    MyHTML_TAG_XMP = 143,
    MyHTML_TAG_ALTGLYPH = 144,
    MyHTML_TAG_ALTGLYPHDEF = 145,
    MyHTML_TAG_ALTGLYPHITEM = 146,
    MyHTML_TAG_ANIMATE = 147,
    MyHTML_TAG_ANIMATECOLOR = 148,
    MyHTML_TAG_ANIMATEMOTION = 149,
    MyHTML_TAG_ANIMATETRANSFORM = 150,
    MyHTML_TAG_CIRCLE = 151,
    MyHTML_TAG_CLIPPATH = 152,
    MyHTML_TAG_COLOR_PROFILE = 153,
    MyHTML_TAG_CURSOR = 154,
    MyHTML_TAG_DEFS = 155,
    MyHTML_TAG_DESC = 156,
    MyHTML_TAG_ELLIPSE = 157,
    MyHTML_TAG_FEBLEND = 158,
    MyHTML_TAG_FECOLORMATRIX = 159,
    MyHTML_TAG_FECOMPONENTTRANSFER = 160,
    MyHTML_TAG_FECOMPOSITE = 161,
    MyHTML_TAG_FECONVOLVEMATRIX = 162,
    MyHTML_TAG_FEDIFFUSELIGHTING = 163,
    MyHTML_TAG_FEDISPLACEMENTMAP = 164,
    MyHTML_TAG_FEDISTANTLIGHT = 165,
    MyHTML_TAG_FEDROPSHADOW = 166,
    MyHTML_TAG_FEFLOOD = 167,
    MyHTML_TAG_FEFUNCA = 168,
    MyHTML_TAG_FEFUNCB = 169,
    MyHTML_TAG_FEFUNCG = 170,
    MyHTML_TAG_FEFUNCR = 171,
    MyHTML_TAG_FEGAUSSIANBLUR = 172,
    MyHTML_TAG_FEIMAGE = 173,
    MyHTML_TAG_FEMERGE = 174,
    MyHTML_TAG_FEMERGENODE = 175,
    MyHTML_TAG_FEMORPHOLOGY = 176,
    MyHTML_TAG_FEOFFSET = 177,
    MyHTML_TAG_FEPOINTLIGHT = 178,
    MyHTML_TAG_FESPECULARLIGHTING = 179,
    MyHTML_TAG_FESPOTLIGHT = 180,
    MyHTML_TAG_FETILE = 181,
    MyHTML_TAG_FETURBULENCE = 182,
    MyHTML_TAG_FILTER = 183,
    MyHTML_TAG_FONT_FACE = 184,
    MyHTML_TAG_FONT_FACE_FORMAT = 185,
    MyHTML_TAG_FONT_FACE_NAME = 186,
    MyHTML_TAG_FONT_FACE_SRC = 187,
    MyHTML_TAG_FONT_FACE_URI = 188,
    MyHTML_TAG_FOREIGNOBJECT = 189,
    MyHTML_TAG_G = 190,
    MyHTML_TAG_GLYPH = 191,
    MyHTML_TAG_GLYPHREF = 192,
    MyHTML_TAG_HKERN = 193,
    MyHTML_TAG_LINE = 194,
    MyHTML_TAG_LINEARGRADIENT = 195,
    MyHTML_TAG_MARKER = 196,
    MyHTML_TAG_MASK = 197,
    MyHTML_TAG_METADATA = 198,
    MyHTML_TAG_MISSING_GLYPH = 199,
    MyHTML_TAG_MPATH = 200,
    MyHTML_TAG_PATH = 201,
    MyHTML_TAG_PATTERN = 202,
    MyHTML_TAG_POLYGON = 203,
    MyHTML_TAG_POLYLINE = 204,
    MyHTML_TAG_RADIALGRADIENT = 205,
    MyHTML_TAG_RECT = 206,
    MyHTML_TAG_SET = 207,
    MyHTML_TAG_STOP = 208,
    MyHTML_TAG_SWITCH = 209,
    MyHTML_TAG_SYMBOL = 210,
    MyHTML_TAG_TEXT = 211,
    MyHTML_TAG_TEXTPATH = 212,
    MyHTML_TAG_TREF = 213,
    MyHTML_TAG_TSPAN = 214,
    MyHTML_TAG_USE = 215,
    MyHTML_TAG_VIEW = 216,
    MyHTML_TAG_VKERN = 217,
    MyHTML_TAG_MATH = 218,
    MyHTML_TAG_MACTION = 219,
    MyHTML_TAG_MALIGNGROUP = 220,
    MyHTML_TAG_MALIGNMARK = 221,
    MyHTML_TAG_MENCLOSE = 222,
    MyHTML_TAG_MERROR = 223,
    MyHTML_TAG_MFENCED = 224,
    MyHTML_TAG_MFRAC = 225,
    MyHTML_TAG_MGLYPH = 226,
    MyHTML_TAG_MI = 227,
    MyHTML_TAG_MLABELEDTR = 228,
    MyHTML_TAG_MLONGDIV = 229,
    MyHTML_TAG_MMULTISCRIPTS = 230,
    MyHTML_TAG_MN = 231,
    MyHTML_TAG_MO = 232,
    MyHTML_TAG_MOVER = 233,
    MyHTML_TAG_MPADDED = 234,
    MyHTML_TAG_MPHANTOM = 235,
    MyHTML_TAG_MROOT = 236,
    MyHTML_TAG_MROW = 237,
    MyHTML_TAG_MS = 238,
    MyHTML_TAG_MSCARRIES = 239,
    MyHTML_TAG_MSCARRY = 240,
    MyHTML_TAG_MSGROUP = 241,
    MyHTML_TAG_MSLINE = 242,
    MyHTML_TAG_MSPACE = 243,
    MyHTML_TAG_MSQRT = 244,
    MyHTML_TAG_MSROW = 245,
    MyHTML_TAG_MSTACK = 246,
    MyHTML_TAG_MSTYLE = 247,
    MyHTML_TAG_MSUB = 248,
    MyHTML_TAG_MSUP = 249,
    MyHTML_TAG_MSUBSUP = 250,
    MyHTML_TAG__END_OF_FILE = 251,
    MyHTML_TAG_LAST_ENTRY = 252,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_status {
    MyHTML_STATUS_OK = 0,
    MyHTML_STATUS_ERROR = 1,
    MyHTML_STATUS_ERROR_MEMORY_ALLOCATION = 2,
    MyHTML_STATUS_RULES_ERROR_MEMORY_ALLOCATION = 36964,
    MyHTML_STATUS_TOKENIZER_ERROR_MEMORY_ALLOCATION = 37164,
    MyHTML_STATUS_TOKENIZER_ERROR_FRAGMENT_INIT = 37165,
    MyHTML_STATUS_TAGS_ERROR_MEMORY_ALLOCATION = 37264,
    MyHTML_STATUS_TAGS_ERROR_MCOBJECT_CREATE = 37265,
    MyHTML_STATUS_TAGS_ERROR_MCOBJECT_MALLOC = 37266,
    MyHTML_STATUS_TAGS_ERROR_MCOBJECT_CREATE_NODE = 37267,
    MyHTML_STATUS_TAGS_ERROR_CACHE_MEMORY_ALLOCATION = 37268,
    MyHTML_STATUS_TAGS_ERROR_INDEX_MEMORY_ALLOCATION = 37269,
    MyHTML_STATUS_TREE_ERROR_MEMORY_ALLOCATION = 37364,
    MyHTML_STATUS_TREE_ERROR_MCOBJECT_CREATE = 37365,
    MyHTML_STATUS_TREE_ERROR_MCOBJECT_INIT = 37366,
    MyHTML_STATUS_TREE_ERROR_MCOBJECT_CREATE_NODE = 37367,
    MyHTML_STATUS_TREE_ERROR_INCOMING_BUFFER_CREATE = 37368,
    MyHTML_STATUS_ATTR_ERROR_ALLOCATION = 37464,
    MyHTML_STATUS_ATTR_ERROR_CREATE = 37465,
    MyHTML_STATUS_STREAM_BUFFER_ERROR_CREATE = 37632,
    MyHTML_STATUS_STREAM_BUFFER_ERROR_INIT = 37633,
    MyHTML_STATUS_STREAM_BUFFER_ENTRY_ERROR_CREATE = 37634,
    MyHTML_STATUS_STREAM_BUFFER_ENTRY_ERROR_INIT = 37635,
    MyHTML_STATUS_STREAM_BUFFER_ERROR_ADD_ENTRY = 37636,
}
pub use self::myhtml_status as myhtml_status_t;
pub const myhtml_namespace_MyHTML_NAMESPACE_LAST_ENTRY: myhtml_namespace =
    myhtml_namespace::MyHTML_NAMESPACE_ANY;
#[repr(u32)]
/// @struct myhtml namespace
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_namespace {
    MyHTML_NAMESPACE_UNDEF = 0,
    MyHTML_NAMESPACE_HTML = 1,
    MyHTML_NAMESPACE_MATHML = 2,
    MyHTML_NAMESPACE_SVG = 3,
    MyHTML_NAMESPACE_XLINK = 4,
    MyHTML_NAMESPACE_XML = 5,
    MyHTML_NAMESPACE_XMLNS = 6,
    MyHTML_NAMESPACE_ANY = 7,
}
pub use self::myhtml_namespace as myhtml_namespace_t;
#[repr(u32)]
/// @struct myhtml options
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_options {
    MyHTML_OPTIONS_DEFAULT = 0,
    MyHTML_OPTIONS_PARSE_MODE_SINGLE = 1,
    MyHTML_OPTIONS_PARSE_MODE_ALL_IN_ONE = 2,
    MyHTML_OPTIONS_PARSE_MODE_SEPARATELY = 4,
}
#[repr(u32)]
/// @struct myhtml_tree parse flags
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_tree_parse_flags {
    MyHTML_TREE_PARSE_FLAGS_CLEAN = 0,
    MyHTML_TREE_PARSE_FLAGS_WITHOUT_BUILD_TREE = 1,
    MyHTML_TREE_PARSE_FLAGS_WITHOUT_PROCESS_TOKEN = 3,
    MyHTML_TREE_PARSE_FLAGS_SKIP_WHITESPACE_TOKEN = 4,
    MyHTML_TREE_PARSE_FLAGS_WITHOUT_DOCTYPE_IN_TREE = 8,
}
pub use self::myhtml_tree_parse_flags as myhtml_tree_parse_flags_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml {
    _unused: [u8; 0],
}
/// @struct myhtml_t MyHTML
///
/// Basic structure. Create once for using many times.
pub type myhtml_t = myhtml;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_tree {
    _unused: [u8; 0],
}
/// @struct myhtml_tree_t MyHTML_TREE
///
/// Secondary structure. Create once for using many times.
pub type myhtml_tree_t = myhtml_tree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_token {
    _unused: [u8; 0],
}
/// @struct myhtml_token_t MyHTML_TOKEN
pub type myhtml_token_t = myhtml_token;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_token_attr {
    _unused: [u8; 0],
}
pub type myhtml_tree_attr_t = myhtml_token_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_tree_node {
    _unused: [u8; 0],
}
pub type myhtml_tree_node_t = myhtml_tree_node;
/// MyHTML_TAG
///
pub type myhtml_tag_id_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_tag {
    _unused: [u8; 0],
}
pub type myhtml_tag_t = myhtml_tag;
/// @struct myhtml_collection_t
#[repr(C)]
#[derive(Debug, Copy)]
pub struct myhtml_collection {
    pub list: *mut *mut myhtml_tree_node_t,
    pub size: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_myhtml_collection() {
    assert_eq!(::std::mem::size_of::<myhtml_collection>() , 24usize , concat !
               ( "Size of: " , stringify ! ( myhtml_collection ) ));
    assert_eq! (::std::mem::align_of::<myhtml_collection>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( myhtml_collection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_collection ) ) . list as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_collection ) ,
                "::" , stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_collection ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_collection ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_collection ) ) . length as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_collection ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for myhtml_collection {
    fn clone(&self) -> Self { *self }
}
pub type myhtml_collection_t = myhtml_collection;
/// @struct myhtml_position_t
#[repr(C)]
#[derive(Debug, Copy)]
pub struct myhtml_position {
    pub begin: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_myhtml_position() {
    assert_eq!(::std::mem::size_of::<myhtml_position>() , 16usize , concat ! (
               "Size of: " , stringify ! ( myhtml_position ) ));
    assert_eq! (::std::mem::align_of::<myhtml_position>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( myhtml_position ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_position ) ) . begin as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_position ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_position ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_position ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for myhtml_position {
    fn clone(&self) -> Self { *self }
}
pub type myhtml_position_t = myhtml_position;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct myhtml_token_node {
    _unused: [u8; 0],
}
/// @struct myhtml_token_node_t
pub type myhtml_token_node_t = myhtml_token_node;
/// @struct myhtml_version_t
#[repr(C)]
#[derive(Debug, Copy)]
pub struct myhtml_version {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub patch: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_myhtml_version() {
    assert_eq!(::std::mem::size_of::<myhtml_version>() , 12usize , concat ! (
               "Size of: " , stringify ! ( myhtml_version ) ));
    assert_eq! (::std::mem::align_of::<myhtml_version>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( myhtml_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_version ) ) . major as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_version ) , "::"
                , stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_version ) ) . minor as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_version ) , "::"
                , stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const myhtml_version ) ) . patch as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( myhtml_version ) , "::"
                , stringify ! ( patch ) ));
}
impl Clone for myhtml_version {
    fn clone(&self) -> Self { *self }
}
pub type myhtml_version_t = myhtml_version;
pub type myhtml_callback_token_f =
    ::std::option::Option<unsafe extern "C" fn(tree: *mut myhtml_tree_t,
                                               token:
                                                   *mut myhtml_token_node_t,
                                               ctx:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type myhtml_callback_tree_node_f =
    ::std::option::Option<unsafe extern "C" fn(tree: *mut myhtml_tree_t,
                                               node: *mut myhtml_tree_node_t,
                                               ctx:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    /// Create a MyHTML structure
///
/// @return myhtml_t* if successful, otherwise an NULL value.
    pub fn myhtml_create() -> *mut myhtml_t;
}
extern "C" {
    /// Allocating and Initialization resources for a MyHTML structure
///
/// @param[in] myhtml_t*
/// @param[in] work options, how many threads will be.
/// Default: MyHTML_OPTIONS_PARSE_MODE_SEPARATELY
///
/// @param[in] thread count, it depends on the choice of work options
/// Default: 1
///
/// @param[in] queue size for a tokens. Dynamically increasing the specified number here. Default: 4096
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status value.
    pub fn myhtml_init(myhtml: *mut myhtml_t, opt: myhtml_options,
                       thread_count: usize, queue_size: usize) -> mystatus_t;
}
extern "C" {
    /// Clears queue and threads resources
///
/// @param[in] myhtml_t*
    pub fn myhtml_clean(myhtml: *mut myhtml_t);
}
extern "C" {
    /// Destroy of a MyHTML structure
///
/// @param[in] myhtml_t*
/// @return NULL if successful, otherwise an MyHTML structure.
    pub fn myhtml_destroy(myhtml: *mut myhtml_t) -> *mut myhtml_t;
}
extern "C" {
    /// Parsing HTML
///
/// @param[in] previously created structure myhtml_tree_t*
/// @param[in] Input character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
/// @param[in] HTML
/// @param[in] HTML size
///
/// All input character encoding decode to utf-8
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse(tree: *mut myhtml_tree_t, encoding: myencoding_t,
                        html: *const ::std::os::raw::c_char, html_size: usize)
     -> mystatus_t;
}
extern "C" {
    /// Parsing fragment of HTML
///
/// @param[in] previously created structure myhtml_tree_t*
/// @param[in] Input character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
/// @param[in] HTML
/// @param[in] HTML size
/// @param[in] fragment base (root) tag id. Default: MyHTML_TAG_DIV if set 0
/// @param[in] fragment NAMESPACE. Default: MyHTML_NAMESPACE_HTML if set 0
///
/// All input character encoding decode to utf-8
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_fragment(tree: *mut myhtml_tree_t,
                                 encoding: myencoding_t,
                                 html: *const ::std::os::raw::c_char,
                                 html_size: usize, tag_id: myhtml_tag_id_t,
                                 ns: myhtml_namespace) -> mystatus_t;
}
extern "C" {
    /// Parsing HTML in Single Mode.
/// No matter what was said during initialization MyHTML
///
/// @param[in] previously created structure myhtml_tree_t*
/// @param[in] Input character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
/// @param[in] HTML
/// @param[in] HTML size
///
/// All input character encoding decode to utf-8
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_single(tree: *mut myhtml_tree_t,
                               encoding: myencoding_t,
                               html: *const ::std::os::raw::c_char,
                               html_size: usize) -> mystatus_t;
}
extern "C" {
    /// Parsing fragment of HTML in Single Mode.
/// No matter what was said during initialization MyHTML
///
/// @param[in] previously created structure myhtml_tree_t*
/// @param[in] Input character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
/// @param[in] HTML
/// @param[in] HTML size
/// @param[in] fragment base (root) tag id. Default: MyHTML_TAG_DIV if set 0
/// @param[in] fragment NAMESPACE. Default: MyHTML_NAMESPACE_HTML if set 0
///
/// All input character encoding decode to utf-8
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_fragment_single(tree: *mut myhtml_tree_t,
                                        encoding: myencoding_t,
                                        html: *const ::std::os::raw::c_char,
                                        html_size: usize,
                                        tag_id: myhtml_tag_id_t,
                                        ns: myhtml_namespace) -> mystatus_t;
}
extern "C" {
    /// Parsing HTML chunk. For end parsing call myhtml_parse_chunk_end function
///
/// @param[in] myhtml_tree_t*
/// @param[in] HTML
/// @param[in] HTML size
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_chunk(tree: *mut myhtml_tree_t,
                              html: *const ::std::os::raw::c_char,
                              html_size: usize) -> mystatus_t;
}
extern "C" {
    /// Parsing chunk of fragment HTML. For end parsing call myhtml_parse_chunk_end function
///
/// @param[in] myhtml_tree_t*
/// @param[in] HTML
/// @param[in] HTML size
/// @param[in] fragment base (root) tag id. Default: MyHTML_TAG_DIV if set 0
/// @param[in] fragment NAMESPACE. Default: MyHTML_NAMESPACE_HTML if set 0
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_chunk_fragment(tree: *mut myhtml_tree_t,
                                       html: *const ::std::os::raw::c_char,
                                       html_size: usize,
                                       tag_id: myhtml_tag_id_t,
                                       ns: myhtml_namespace) -> mystatus_t;
}
extern "C" {
    /// Parsing HTML chunk in Single Mode.
/// No matter what was said during initialization MyHTML
///
/// @param[in] myhtml_tree_t*
/// @param[in] HTML
/// @param[in] HTML size
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_chunk_single(tree: *mut myhtml_tree_t,
                                     html: *const ::std::os::raw::c_char,
                                     html_size: usize) -> mystatus_t;
}
extern "C" {
    /// Parsing chunk of fragment of HTML in Single Mode.
/// No matter what was said during initialization MyHTML
///
/// @param[in] myhtml_tree_t*
/// @param[in] HTML
/// @param[in] HTML size
/// @param[in] fragment base (root) tag id. Default: MyHTML_TAG_DIV if set 0
/// @param[in] fragment NAMESPACE. Default: MyHTML_NAMESPACE_HTML if set 0
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_chunk_fragment_single(tree: *mut myhtml_tree_t,
                                              html:
                                                  *const ::std::os::raw::c_char,
                                              html_size: usize,
                                              tag_id: myhtml_tag_id_t,
                                              ns: myhtml_namespace)
     -> mystatus_t;
}
extern "C" {
    /// End of parsing HTML chunks
///
/// @param[in] myhtml_tree_t*
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_parse_chunk_end(tree: *mut myhtml_tree_t) -> mystatus_t;
}
extern "C" {
    /// Create a MyHTML_TREE structure
///
/// @return myhtml_tree_t* if successful, otherwise an NULL value.
    pub fn myhtml_tree_create() -> *mut myhtml_tree_t;
}
extern "C" {
    /// Allocating and Initialization resources for a MyHTML_TREE structure
///
/// @param[in] myhtml_tree_t*
/// @param[in] workmyhtml_t*
///
/// @return MyHTML_STATUS_OK if successful, otherwise an error status
    pub fn myhtml_tree_init(tree: *mut myhtml_tree_t, myhtml: *mut myhtml_t)
     -> mystatus_t;
}
extern "C" {
    /// Get Parse Flags of Tree
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_parse_flags_t
    pub fn myhtml_tree_parse_flags(tree: *mut myhtml_tree_t)
     -> myhtml_tree_parse_flags_t;
}
extern "C" {
    /// Set Parse Flags for Tree
/// See enum myhtml_tree_parse_flags in this file
///
/// @example myhtml_tree_parse_flags_set(tree, MyHTML_TREE_PARSE_FLAGS_WITHOUT_BUILD_TREE|
/// MyHTML_TREE_PARSE_FLAGS_WITHOUT_DOCTYPE_IN_TREE|
/// MyHTML_TREE_PARSE_FLAGS_SKIP_WHITESPACE_TOKEN);
///
/// @param[in] myhtml_tree_t*
/// @param[in] parse flags. You can combine their
    pub fn myhtml_tree_parse_flags_set(tree: *mut myhtml_tree_t,
                                       parse_flags:
                                           myhtml_tree_parse_flags_t);
}
extern "C" {
    /// Clears resources before new parsing
///
/// @param[in] myhtml_tree_t*
    pub fn myhtml_tree_clean(tree: *mut myhtml_tree_t);
}
extern "C" {
    /// Add child node to node. If children already exists it will be added to the last
///
/// @param[in] myhtml_tree_node_t* The node to which we add child node
/// @param[in] myhtml_tree_node_t* The node which adds
    pub fn myhtml_tree_node_add_child(root: *mut myhtml_tree_node_t,
                                      node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// Add a node immediately before the existing node
///
/// @param[in] myhtml_tree_node_t* add for this node
/// @param[in] myhtml_tree_node_t* add this node
    pub fn myhtml_tree_node_insert_before(root: *mut myhtml_tree_node_t,
                                          node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// Add a node immediately after the existing node
///
/// @param[in] myhtml_tree_node_t* add for this node
/// @param[in] myhtml_tree_node_t* add this node
    pub fn myhtml_tree_node_insert_after(root: *mut myhtml_tree_node_t,
                                         node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// Destroy of a MyHTML_TREE structure
///
/// @param[in] myhtml_tree_t*
///
/// @return NULL if successful, otherwise an MyHTML_TREE structure
    pub fn myhtml_tree_destroy(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_t;
}
extern "C" {
    /// Get myhtml_t* from a myhtml_tree_t*
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_t* if exists, otherwise a NULL value
    pub fn myhtml_tree_get_myhtml(tree: *mut myhtml_tree_t) -> *mut myhtml_t;
}
extern "C" {
    /// Get myhtml_tag_t* from a myhtml_tree_t*
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tag_t* if exists, otherwise a NULL value
    pub fn myhtml_tree_get_tag(tree: *mut myhtml_tree_t) -> *mut myhtml_tag_t;
}
extern "C" {
    /// Get Tree Document (Root of Tree)
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_tree_get_document(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get node HTML (Document -> HTML, Root of HTML Document)
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_tree_get_node_html(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get node HEAD (Document -> HTML -> HEAD)
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_tree_get_node_head(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get node BODY (Document -> HTML -> BODY)
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_tree_get_node_body(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get mchar_async_t object
///
/// @param[in] myhtml_tree_t*
///
/// @return mchar_async_t* if exists, otherwise a NULL value
    pub fn myhtml_tree_get_mchar(tree: *mut myhtml_tree_t)
     -> *mut mchar_async_t;
}
extern "C" {
    /// Get node_id from main thread for mchar_async_t object
///
/// @param[in] myhtml_tree_t*
///
/// @return size_t, node id
    pub fn myhtml_tree_get_mchar_node_id(tree: *mut myhtml_tree_t) -> usize;
}
extern "C" {
    /// Get first Incoming Buffer
///
/// @param[in] myhtml_tree_t*
///
/// @return mycore_incoming_buffer_t* if successful, otherwise a NULL value
    pub fn myhtml_tree_incoming_buffer_first(tree: *mut myhtml_tree_t)
     -> *mut mycore_incoming_buffer_t;
}
extern "C" {
    /// Get first (begin) node of tree
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_node_first(tree: *mut myhtml_tree_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get nodes by tag id
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, creates new collection if NULL
/// @param[in] tag id
/// @param[out] status of this operation
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_tag_id(tree: *mut myhtml_tree_t,
                                      collection: *mut myhtml_collection_t,
                                      tag_id: myhtml_tag_id_t,
                                      status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by tag name
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, creates new collection if NULL
/// @param[in] tag name
/// @param[in] tag name length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_name(tree: *mut myhtml_tree_t,
                                    collection: *mut myhtml_collection_t,
                                    name: *const ::std::os::raw::c_char,
                                    length: usize, status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute key
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] find key
/// @param[in] find key length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_key(tree: *mut myhtml_tree_t,
                                             collection:
                                                 *mut myhtml_collection_t,
                                             scope_node:
                                                 *mut myhtml_tree_node_t,
                                             key:
                                                 *const ::std::os::raw::c_char,
                                             key_len: usize,
                                             status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; exactly equal; like a [foo="bar"]
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value(tree: *mut myhtml_tree_t,
                                               collection:
                                                   *mut myhtml_collection_t,
                                               node: *mut myhtml_tree_node_t,
                                               case_insensitive: bool,
                                               key:
                                                   *const ::std::os::raw::c_char,
                                               key_len: usize,
                                               value:
                                                   *const ::std::os::raw::c_char,
                                               value_len: usize,
                                               status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; whitespace separated; like a [foo~="bar"]
///
/// @example if value="bar" and node attr value="lalala bar bebebe", then this node is found
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value_whitespace_separated(tree:
                                                                        *mut myhtml_tree_t,
                                                                    collection:
                                                                        *mut myhtml_collection_t,
                                                                    node:
                                                                        *mut myhtml_tree_node_t,
                                                                    case_insensitive:
                                                                        bool,
                                                                    key:
                                                                        *const ::std::os::raw::c_char,
                                                                    key_len:
                                                                        usize,
                                                                    value:
                                                                        *const ::std::os::raw::c_char,
                                                                    value_len:
                                                                        usize,
                                                                    status:
                                                                        *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; value begins exactly with the string; like a [foo^="bar"]
///
/// @example if value="bar" and node attr value="barmumumu", then this node is found
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value_begin(tree: *mut myhtml_tree_t,
                                                     collection:
                                                         *mut myhtml_collection_t,
                                                     node:
                                                         *mut myhtml_tree_node_t,
                                                     case_insensitive: bool,
                                                     key:
                                                         *const ::std::os::raw::c_char,
                                                     key_len: usize,
                                                     value:
                                                         *const ::std::os::raw::c_char,
                                                     value_len: usize,
                                                     status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; value ends exactly with the string; like a [foo$="bar"]
///
/// @example if value="bar" and node attr value="mumumubar", then this node is found
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value_end(tree: *mut myhtml_tree_t,
                                                   collection:
                                                       *mut myhtml_collection_t,
                                                   node:
                                                       *mut myhtml_tree_node_t,
                                                   case_insensitive: bool,
                                                   key:
                                                       *const ::std::os::raw::c_char,
                                                   key_len: usize,
                                                   value:
                                                       *const ::std::os::raw::c_char,
                                                   value_len: usize,
                                                   status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; value contains the substring; like a [foo*="bar"]
///
/// @example if value="bar" and node attr value="bububarmumu", then this node is found
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] status of this operation, optional
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value_contain(tree:
                                                           *mut myhtml_tree_t,
                                                       collection:
                                                           *mut myhtml_collection_t,
                                                       node:
                                                           *mut myhtml_tree_node_t,
                                                       case_insensitive: bool,
                                                       key:
                                                           *const ::std::os::raw::c_char,
                                                       key_len: usize,
                                                       value:
                                                           *const ::std::os::raw::c_char,
                                                       value_len: usize,
                                                       status:
                                                           *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by attribute value; attribute value is a hyphen-separated list of values beginning;
/// like a [foo|="bar"]
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, optional; creates new collection if NULL
/// @param[in] myhtml_tree_node_t*, optional; scope node; html if NULL
/// @param[in] case-insensitive if true
/// @param[in] find in key; if NULL find in all attributes
/// @param[in] find in key length; if 0 find in all attributes
/// @param[in] find value
/// @param[in] find value length
/// @param[out] optional; status of this operation
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_attribute_value_hyphen_separated(tree:
                                                                    *mut myhtml_tree_t,
                                                                collection:
                                                                    *mut myhtml_collection_t,
                                                                node:
                                                                    *mut myhtml_tree_node_t,
                                                                case_insensitive:
                                                                    bool,
                                                                key:
                                                                    *const ::std::os::raw::c_char,
                                                                key_len:
                                                                    usize,
                                                                value:
                                                                    *const ::std::os::raw::c_char,
                                                                value_len:
                                                                    usize,
                                                                status:
                                                                    *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by tag id in node scope
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, creates new collection if NULL
/// @param[in] node for search tag_id in children nodes
/// @param[in] tag_id for search
/// @param[out] status of this operation
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_tag_id_in_scope(tree: *mut myhtml_tree_t,
                                               collection:
                                                   *mut myhtml_collection_t,
                                               node: *mut myhtml_tree_node_t,
                                               tag_id: myhtml_tag_id_t,
                                               status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get nodes by tag name in node scope
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_collection_t*, creates new collection if NULL
/// @param[in] node for search tag_id in children nodes
/// @param[in] tag name
/// @param[in] tag name length
/// @param[out] status of this operation
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_get_nodes_by_name_in_scope(tree: *mut myhtml_tree_t,
                                             collection:
                                                 *mut myhtml_collection_t,
                                             node: *mut myhtml_tree_node_t,
                                             html:
                                                 *const ::std::os::raw::c_char,
                                             length: usize,
                                             status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Get next sibling node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if exists, otherwise an NULL value
    pub fn myhtml_node_next(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get previous sibling node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if exists, otherwise an NULL value
    pub fn myhtml_node_prev(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get parent node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if exists, otherwise an NULL value
    pub fn myhtml_node_parent(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get child (first child) of node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if exists, otherwise an NULL value
    pub fn myhtml_node_child(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Get last child of node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if exists, otherwise an NULL value
    pub fn myhtml_node_last_child(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Create new node
///
/// @param[in] myhtml_tree_t*
/// @param[in] tag id, see enum myhtml_tags
/// @param[in] enum myhtml_namespace
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_node_create(tree: *mut myhtml_tree_t,
                              tag_id: myhtml_tag_id_t, ns: myhtml_namespace)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Release allocated resources
///
/// @param[in] myhtml_tree_node_t*
    pub fn myhtml_node_free(node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// Remove node of tree
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t* if successful, otherwise a NULL value
    pub fn myhtml_node_remove(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Remove node of tree and release allocated resources
///
/// @param[in] myhtml_tree_node_t*
    pub fn myhtml_node_delete(node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// Remove nodes of tree recursively and release allocated resources
///
/// @param[in] myhtml_tree_node_t*
    pub fn myhtml_node_delete_recursive(node: *mut myhtml_tree_node_t);
}
extern "C" {
    /// The appropriate place for inserting a node. Insertion with validation.
/// If try insert <a> node to <table> node, then <a> node inserted before <table> node
///
/// @param[in] target node
/// @param[in] insertion node
///
/// @return insertion node if successful, otherwise a NULL value
    pub fn myhtml_node_insert_to_appropriate_place(target:
                                                       *mut myhtml_tree_node_t,
                                                   node:
                                                       *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Append to target node as last child. Insertion without validation.
///
/// @param[in] target node
/// @param[in] insertion node
///
/// @return insertion node if successful, otherwise a NULL value
    pub fn myhtml_node_append_child(target: *mut myhtml_tree_node_t,
                                    node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Append sibling node after target node. Insertion without validation.
///
/// @param[in] target node
/// @param[in] insertion node
///
/// @return insertion node if successful, otherwise a NULL value
    pub fn myhtml_node_insert_after(target: *mut myhtml_tree_node_t,
                                    node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Append sibling node before target node. Insertion without validation.
///
/// @param[in] target node
/// @param[in] insertion node
///
/// @return insertion node if successful, otherwise a NULL value
    pub fn myhtml_node_insert_before(target: *mut myhtml_tree_node_t,
                                     node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_node_t;
}
extern "C" {
    /// Add text for a node with convert character encoding.
///
/// @param[in] target node
/// @param[in] text
/// @param[in] text length
/// @param[in] character encoding
///
/// @return mycore_string_t* if successful, otherwise a NULL value
    pub fn myhtml_node_text_set(node: *mut myhtml_tree_node_t,
                                text: *const ::std::os::raw::c_char,
                                length: usize, encoding: myencoding_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Add text for a node with convert character encoding.
///
/// @param[in] target node
/// @param[in] text
/// @param[in] text length
/// @param[in] character encoding
///
/// @return mycore_string_t* if successful, otherwise a NULL value
    pub fn myhtml_node_text_set_with_charef(node: *mut myhtml_tree_node_t,
                                            text:
                                                *const ::std::os::raw::c_char,
                                            length: usize,
                                            encoding: myencoding_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Get token node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_token_node_t*
    pub fn myhtml_node_token(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_token_node_t;
}
extern "C" {
    /// Get node namespace
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_namespace_t
    pub fn myhtml_node_namespace(node: *mut myhtml_tree_node_t)
     -> myhtml_namespace_t;
}
extern "C" {
    /// Set node namespace
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] myhtml_namespace_t
    pub fn myhtml_node_namespace_set(node: *mut myhtml_tree_node_t,
                                     ns: myhtml_namespace_t);
}
extern "C" {
    /// Get node tag id
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tag_id_t
    pub fn myhtml_node_tag_id(node: *mut myhtml_tree_node_t)
     -> myhtml_tag_id_t;
}
extern "C" {
    /// Node has self-closing flag?
///
/// @param[in] myhtml_tree_node_t*
///
/// @return true or false (1 or 0)
    pub fn myhtml_node_is_close_self(node: *mut myhtml_tree_node_t) -> bool;
}
extern "C" {
    /// Get first attribute of a node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_node_attribute_first(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get last attribute of a node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_node_attribute_last(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get text of a node. Only for a MyHTML_TAG__TEXT or MyHTML_TAG__COMMENT tags
///
/// @param[in] myhtml_tree_node_t*
/// @param[out] optional, text length
///
/// @return const char* if exists, otherwise an NULL value
    pub fn myhtml_node_text(node: *mut myhtml_tree_node_t, length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get mycore_string_t object by Tree node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return mycore_string_t* if exists, otherwise an NULL value
    pub fn myhtml_node_string(node: *mut myhtml_tree_node_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Get raw position for Tree Node in Incoming Buffer
///
/// @example <[BEGIN]div[LENGTH] attr=lalala>
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t
    pub fn myhtml_node_raw_pasition(node: *mut myhtml_tree_node_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get element position for Tree Node in Incoming Buffer
///
/// @example [BEGIN]<div attr=lalala>[LENGTH]
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_node_t
    pub fn myhtml_node_element_pasition(node: *mut myhtml_tree_node_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get data value from tree node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return void*
    pub fn myhtml_node_get_data(node: *mut myhtml_tree_node_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Set data value to tree node
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] void*
    pub fn myhtml_node_set_data(node: *mut myhtml_tree_node_t,
                                data: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Get current tree (myhtml_tree_t*) from node
///
/// @param[in] myhtml_tree_node_t*
///
/// @return myhtml_tree_t*
    pub fn myhtml_node_tree(node: *mut myhtml_tree_node_t)
     -> *mut myhtml_tree_t;
}
extern "C" {
    /// Get next sibling attribute of one node
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_attribute_next(attr: *mut myhtml_tree_attr_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get previous sibling attribute of one node
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_attribute_prev(attr: *mut myhtml_tree_attr_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get attribute namespace
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return enum myhtml_namespace
    pub fn myhtml_attribute_namespace(attr: *mut myhtml_tree_attr_t)
     -> myhtml_namespace_t;
}
extern "C" {
    /// Set attribute namespace
///
/// @param[in] myhtml_tree_attr_t*
/// @param[in] myhtml_namespace_t
    pub fn myhtml_attribute_namespace_set(attr: *mut myhtml_tree_attr_t,
                                          ns: myhtml_namespace_t);
}
extern "C" {
    /// Get attribute key
///
/// @param[in] myhtml_tree_attr_t*
/// @param[out] optional, name length
///
/// @return const char* if exists, otherwise an NULL value
    pub fn myhtml_attribute_key(attr: *mut myhtml_tree_attr_t,
                                length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get attribute value
///
/// @param[in] myhtml_tree_attr_t*
/// @param[out] optional, value length
///
/// @return const char* if exists, otherwise an NULL value
    pub fn myhtml_attribute_value(attr: *mut myhtml_tree_attr_t,
                                  length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get attribute key string
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return mycore_string_t* if exists, otherwise an NULL value
    pub fn myhtml_attribute_key_string(attr: *mut myhtml_tree_attr_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Get attribute value string
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return mycore_string_t* if exists, otherwise an NULL value
    pub fn myhtml_attribute_value_string(attr: *mut myhtml_tree_attr_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Get attribute by key
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] attr key name
/// @param[in] attr key name length
///
/// @return myhtml_tree_attr_t* if exists, otherwise a NULL value
    pub fn myhtml_attribute_by_key(node: *mut myhtml_tree_node_t,
                                   key: *const ::std::os::raw::c_char,
                                   key_len: usize) -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Added attribute to tree node
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] attr key name
/// @param[in] attr key name length
/// @param[in] attr value name
/// @param[in] attr value name length
/// @param[in] character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
///
/// @return created myhtml_tree_attr_t* if successful, otherwise a NULL value
    pub fn myhtml_attribute_add(node: *mut myhtml_tree_node_t,
                                key: *const ::std::os::raw::c_char,
                                key_len: usize,
                                value: *const ::std::os::raw::c_char,
                                value_len: usize, encoding: myencoding_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Remove attribute reference. Not release the resources
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_tree_attr_t* if successful, otherwise a NULL value
    pub fn myhtml_attribute_remove(node: *mut myhtml_tree_node_t,
                                   attr: *mut myhtml_tree_attr_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Remove attribute by key reference. Not release the resources
///
/// @param[in] myhtml_tree_node_t*
/// @param[in] attr key name
/// @param[in] attr key name length
///
/// @return myhtml_tree_attr_t* if successful, otherwise a NULL value
    pub fn myhtml_attribute_remove_by_key(node: *mut myhtml_tree_node_t,
                                          key: *const ::std::os::raw::c_char,
                                          key_len: usize)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Remove attribute and release allocated resources
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_tree_node_t*
/// @param[in] myhtml_tree_attr_t*
///
    pub fn myhtml_attribute_delete(tree: *mut myhtml_tree_t,
                                   node: *mut myhtml_tree_node_t,
                                   attr: *mut myhtml_tree_attr_t);
}
extern "C" {
    /// Release allocated resources
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_tree_attr_t* if successful, otherwise a NULL value
    pub fn myhtml_attribute_free(tree: *mut myhtml_tree_t,
                                 attr: *mut myhtml_tree_attr_t);
}
extern "C" {
    /// Get raw position for Attribute Key in Incoming Buffer
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_position_t
    pub fn myhtml_attribute_key_raw_position(attr: *mut myhtml_tree_attr_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get raw position for Attribute Value in Incoming Buffer
///
/// @param[in] myhtml_tree_attr_t*
///
/// @return myhtml_position_t
    pub fn myhtml_attribute_value_raw_position(attr: *mut myhtml_tree_attr_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get token node tag id
///
/// @param[in] myhtml_token_node_t*
///
/// @return myhtml_tag_id_t
    pub fn myhtml_token_node_tag_id(token_node: *mut myhtml_token_node_t)
     -> myhtml_tag_id_t;
}
extern "C" {
    /// Get raw position for Token Node in Incoming Buffer
///
/// @example <[BEGIN]div[LENGTH] attr=lalala>
///
/// @param[in] myhtml_token_node_t*
///
/// @return myhtml_position_t
    pub fn myhtml_token_node_raw_pasition(token_node:
                                              *mut myhtml_token_node_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get element position for Token Node in Incoming Buffer
///
/// @example [BEGIN]<div attr=lalala>[LENGTH]
///
/// @param[in] myhtml_token_node_t*
///
/// @return myhtml_position_t
    pub fn myhtml_token_node_element_pasition(token_node:
                                                  *mut myhtml_token_node_t)
     -> myhtml_position_t;
}
extern "C" {
    /// Get first attribute of a token node
///
/// @param[in] myhtml_token_node_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_token_node_attribute_first(token_node:
                                                 *mut myhtml_token_node_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get last attribute of a token node
///
/// @param[in] myhtml_token_node_t*
///
/// @return myhtml_tree_attr_t* if exists, otherwise an NULL value
    pub fn myhtml_token_node_attribute_last(token_node:
                                                *mut myhtml_token_node_t)
     -> *mut myhtml_tree_attr_t;
}
extern "C" {
    /// Get text of a token node. Only for a MyHTML_TAG__TEXT or MyHTML_TAG__COMMENT tags
///
/// @param[in] myhtml_token_node_t*
/// @param[out] optional, text length
///
/// @return const char* if exists, otherwise an NULL value
    pub fn myhtml_token_node_text(token_node: *mut myhtml_token_node_t,
                                  length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get mycore_string_t object by token node
///
/// @param[in] myhtml_token_node_t*
///
/// @return mycore_string_t* if exists, otherwise an NULL value
    pub fn myhtml_token_node_string(token_node: *mut myhtml_token_node_t)
     -> *mut mycore_string_t;
}
extern "C" {
    /// Token node has closing flag?
///
/// @param[in] myhtml_tree_node_t*
///
/// @return true or false
    pub fn myhtml_token_node_is_close(token_node: *mut myhtml_token_node_t)
     -> bool;
}
extern "C" {
    /// Token node has self-closing flag?
///
/// @param[in] myhtml_tree_node_t*
///
/// @return true or false (1 or 0)
    pub fn myhtml_token_node_is_close_self(token_node:
                                               *mut myhtml_token_node_t)
     -> bool;
}
extern "C" {
    /// Wait for process token all parsing stage. Need if you use thread mode
///
/// @param[in] myhtml_token_t*
/// @param[in] myhtml_token_node_t*
    pub fn myhtml_token_node_wait_for_done(token: *mut myhtml_token_t,
                                           node: *mut myhtml_token_node_t);
}
extern "C" {
    /// Get tag name by tag id
///
/// @param[in] myhtml_tree_t*
/// @param[in] tag id
/// @param[out] optional, name length
///
/// @return const char* if exists, otherwise a NULL value
    pub fn myhtml_tag_name_by_id(tree: *mut myhtml_tree_t,
                                 tag_id: myhtml_tag_id_t, length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get tag id by name
///
/// @param[in] myhtml_tree_t*
/// @param[in] tag name
/// @param[in] tag name length
///
/// @return tag id
    pub fn myhtml_tag_id_by_name(tree: *mut myhtml_tree_t,
                                 tag_name: *const ::std::os::raw::c_char,
                                 length: usize) -> myhtml_tag_id_t;
}
extern "C" {
    /// Create collection
///
/// @param[in] list size
/// @param[out] optional, status of operation
///
/// @return myhtml_collection_t* if successful, otherwise an NULL value
    pub fn myhtml_collection_create(size: usize, status: *mut mystatus_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Clears collection
///
/// @param[in] myhtml_collection_t*
    pub fn myhtml_collection_clean(collection: *mut myhtml_collection_t);
}
extern "C" {
    /// Destroy allocated resources
///
/// @param[in] myhtml_collection_t*
///
/// @return NULL if successful, otherwise an myhtml_collection_t* structure
    pub fn myhtml_collection_destroy(collection: *mut myhtml_collection_t)
     -> *mut myhtml_collection_t;
}
extern "C" {
    /// Check size by length and increase if necessary
///
/// @param[in] myhtml_collection_t*
/// @param[in] need nodes
/// @param[in] upto_length: count for up if nodes not exists
/// (current length + need + upto_length + 1)
///
/// @return NULL if successful, otherwise an myhtml_collection_t* structure
    pub fn myhtml_collection_check_size(collection: *mut myhtml_collection_t,
                                        need: usize, upto_length: usize)
     -> mystatus_t;
}
extern "C" {
    /// Set character encoding for input stream
///
/// @param[in] myhtml_tree_t*
/// @param[in] Input character encoding
///
    pub fn myhtml_encoding_set(tree: *mut myhtml_tree_t,
                               encoding: myencoding_t);
}
extern "C" {
    /// Get character encoding for current stream
///
/// @param[in] myhtml_tree_t*
///
/// @return myencoding_t
    pub fn myhtml_encoding_get(tree: *mut myhtml_tree_t) -> myencoding_t;
}
extern "C" {
    /// Get namespace text by namespace type (id)
///
/// @param[in] myhtml_namespace_t
/// @param[out] optional, length of returned text
///
/// @return text if successful, otherwise a NULL value
    pub fn myhtml_namespace_name_by_id(ns: myhtml_namespace_t,
                                       length: *mut usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get namespace type (id) by namespace text
///
/// @param[in] const char*, namespace text
/// @param[in] size of namespace text
/// @param[out] detected namespace type (id)
///
/// @return true if detect, otherwise false
    pub fn myhtml_namespace_id_by_name(name: *const ::std::os::raw::c_char,
                                       length: usize,
                                       ns: *mut myhtml_namespace_t) -> bool;
}
extern "C" {
    /// Get current callback for tokens before processing
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_callback_token_f
    pub fn myhtml_callback_before_token_done(tree: *mut myhtml_tree_t)
     -> myhtml_callback_token_f;
}
extern "C" {
    /// Get current callback for tokens after processing
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_callback_token_f
    pub fn myhtml_callback_after_token_done(tree: *mut myhtml_tree_t)
     -> myhtml_callback_token_f;
}
extern "C" {
    /// Set callback for tokens before processing
///
/// Warning!
/// If you using thread mode parsing then this callback calls from thread (not Main thread)
/// If you build MyHTML without thread or using MyHTML_OPTIONS_PARSE_MODE_SINGLE for create myhtml_t object
/// then this callback calls from Main thread
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_callback_token_f callback function
    pub fn myhtml_callback_before_token_done_set(tree: *mut myhtml_tree_t,
                                                 func:
                                                     myhtml_callback_token_f,
                                                 ctx:
                                                     *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Set callback for tokens after processing
///
/// Warning!
/// If you using thread mode parsing then this callback calls from thread (not Main thread)
/// If you build MyHTML without thread or using MyHTML_OPTIONS_PARSE_MODE_SINGLE for create myhtml_t object
/// then this callback calls from Main thread
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_callback_token_f callback function
    pub fn myhtml_callback_after_token_done_set(tree: *mut myhtml_tree_t,
                                                func: myhtml_callback_token_f,
                                                ctx:
                                                    *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Get current callback for tree node after inserted
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_callback_tree_node_f
    pub fn myhtml_callback_tree_node_insert(tree: *mut myhtml_tree_t)
     -> myhtml_callback_tree_node_f;
}
extern "C" {
    /// Get current callback for tree node after removed
///
/// @param[in] myhtml_tree_t*
///
/// @return myhtml_callback_tree_node_f
    pub fn myhtml_callback_tree_node_remove(tree: *mut myhtml_tree_t)
     -> myhtml_callback_tree_node_f;
}
extern "C" {
    /// Set callback for tree node after inserted
///
/// Warning!
/// If you using thread mode parsing then this callback calls from thread (not Main thread)
/// If you build MyHTML without thread or using MyHTML_OPTIONS_PARSE_MODE_SINGLE for create myhtml_t object
/// then this callback calls from Main thread
///
/// Warning!!!
/// If you well access to attributes or text for node and you using thread mode then
/// you need wait for token processing done. See myhtml_token_node_wait_for_done
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_callback_tree_node_f callback function
    pub fn myhtml_callback_tree_node_insert_set(tree: *mut myhtml_tree_t,
                                                func:
                                                    myhtml_callback_tree_node_f,
                                                ctx:
                                                    *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Set callback for tree node after removed
///
/// Warning!
/// If you using thread mode parsing then this callback calls from thread (not Main thread)
/// If you build MyHTML without thread or using MyHTML_OPTIONS_PARSE_MODE_SINGLE for create myhtml_t object
/// then this callback calls from Main thread
///
/// Warning!!!
/// If you well access to attributes or text for node and you using thread mode then
/// you need wait for token processing done. See myhtml_token_node_wait_for_done
///
/// @param[in] myhtml_tree_t*
/// @param[in] myhtml_callback_tree_node_f callback function
    pub fn myhtml_callback_tree_node_remove_set(tree: *mut myhtml_tree_t,
                                                func:
                                                    myhtml_callback_tree_node_f,
                                                ctx:
                                                    *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Tree fragment serialization
/// The same as myhtml_serialization_tree_buffer function
    pub fn myhtml_serialization(scope_node: *mut myhtml_tree_node_t,
                                str: *mut mycore_string_raw_t) -> mystatus_t;
}
extern "C" {
    /// Only one tree node serialization
/// The same as myhtml_serialization_node_buffer function
    pub fn myhtml_serialization_node(node: *mut myhtml_tree_node_t,
                                     str: *mut mycore_string_raw_t)
     -> mystatus_t;
}
extern "C" {
    /// Serialize tree to an output string
///
/// @param[in] myhtml_tree_t*
/// @param[in] scope node
/// @param[in] mycore_string_raw_t*
///
/// @return true if successful, otherwise false
    pub fn myhtml_serialization_tree_buffer(scope_node:
                                                *mut myhtml_tree_node_t,
                                            str: *mut mycore_string_raw_t)
     -> mystatus_t;
}
extern "C" {
    /// Serialize node to an output string
///
/// @param[in] myhtml_tree_t*
/// @param[in] node
/// @param[in] mycore_string_raw_t*
///
/// @return true if successful, otherwise false
    pub fn myhtml_serialization_node_buffer(node: *mut myhtml_tree_node_t,
                                            str: *mut mycore_string_raw_t)
     -> mystatus_t;
}
extern "C" {
    /// The serialize function for an entire tree
///
/// @param[in] tree        the tree to be serialized
/// @param[in] scope_node  the scope_node
/// @param[in] callback    function that will be called for all strings that have to be printed
/// @param[in] ptr         user-supplied pointer
///
/// @return true if successful, otherwise false
    pub fn myhtml_serialization_tree_callback(scope_node:
                                                  *mut myhtml_tree_node_t,
                                              callback:
                                                  mycore_callback_serialize_f,
                                              ptr:
                                                  *mut ::std::os::raw::c_void)
     -> mystatus_t;
}
extern "C" {
    /// The serialize function for a single node
///
/// @param[in] tree        the tree to be serialized
/// @param[in] node        the node that is going to be serialized
/// @param[in] callback    function that will be called for all strings that have to be printed
/// @param[in] ptr         user-supplied pointer
///
/// @return true if successful, otherwise false
    pub fn myhtml_serialization_node_callback(node: *mut myhtml_tree_node_t,
                                              callback:
                                                  mycore_callback_serialize_f,
                                              ptr:
                                                  *mut ::std::os::raw::c_void)
     -> mystatus_t;
}
extern "C" {
    /// Get current version
///
/// @return myhtml_version_t
    pub fn myhtml_version() -> myhtml_version_t;
}
