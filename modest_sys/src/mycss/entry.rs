/* automatically generated by rust-bindgen */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type mystatus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: usize,
    pub length: usize,
    pub mchar: *mut mchar_async_t,
    pub node_idx: usize,
}
#[test]
fn bindgen_test_layout_mycore_string() {
    assert_eq!(::std::mem::size_of::<mycore_string>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mycore_string ) ));
    assert_eq! (::std::mem::align_of::<mycore_string>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycore_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . length as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . mchar as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( mchar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . node_idx as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( node_idx ) ));
}
impl Clone for mycore_string {
    fn clone(&self) -> Self { *self }
}
pub type mycore_string_t = mycore_string;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_incoming_buffer {
    pub data: *const ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub offset: usize,
    pub prev: *mut mycore_incoming_buffer,
    pub next: *mut mycore_incoming_buffer,
}
#[test]
fn bindgen_test_layout_mycore_incoming_buffer() {
    assert_eq!(::std::mem::size_of::<mycore_incoming_buffer>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( mycore_incoming_buffer )
               ));
    assert_eq! (::std::mem::align_of::<mycore_incoming_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycore_incoming_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . prev as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . next as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( next ) ));
}
impl Clone for mycore_incoming_buffer {
    fn clone(&self) -> Self { *self }
}
pub type mycore_incoming_buffer_t = mycore_incoming_buffer;
pub const myhtml_namespace_MyHTML_NAMESPACE_LAST_ENTRY: myhtml_namespace =
    myhtml_namespace::MyHTML_NAMESPACE_ANY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myhtml_namespace {
    MyHTML_NAMESPACE_UNDEF = 0,
    MyHTML_NAMESPACE_HTML = 1,
    MyHTML_NAMESPACE_MATHML = 2,
    MyHTML_NAMESPACE_SVG = 3,
    MyHTML_NAMESPACE_XLINK = 4,
    MyHTML_NAMESPACE_XML = 5,
    MyHTML_NAMESPACE_XMLNS = 6,
    MyHTML_NAMESPACE_ANY = 7,
}
pub use self::myhtml_namespace as myhtml_namespace_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_entry {
    pub mycss: *mut mycss_t,
    pub token: *mut mycss_token_t,
    pub stylesheet: *mut mycss_stylesheet_t,
    pub mchar: *mut mchar_async_t,
    pub mchar_node_id: usize,
    pub mchar_value_node_id: usize,
    pub mcobject_string_entries: *mut mcobject_t,
    pub ns: *mut mycss_namespace_t,
    pub selectors: *mut mycss_selectors_t,
    pub anb: *mut mycss_an_plus_b_t,
    pub media: *mut mycss_media_t,
    pub declaration: *mut mycss_declaration_t,
    pub values: *mut *mut ::std::os::raw::c_void,
    pub mcobject_incoming_buffer: *mut mcobject_t,
    pub first_buffer: *mut mycore_incoming_buffer_t,
    pub current_buffer: *mut mycore_incoming_buffer_t,
    pub type_: mycss_entry_type_t,
    pub encoding: myencoding_t,
    pub state: mycss_tokenizer_state_t,
    pub state_back: mycss_tokenizer_state_t,
    pub parser_list: *mut mycss_entry_parser_list_t,
    pub parser: mycss_parser_token_f,
    pub parser_switch: mycss_parser_token_f,
    pub parser_error: mycss_parser_token_f,
    pub parser_original: mycss_parser_token_f,
    pub parser_ending_token: mycss_token_type_t,
    pub token_ready_callback: mycss_token_ready_callback_f,
    pub callback_selector_done: mycss_callback_selector_done_f,
    pub token_counter: usize,
    pub help_counter: usize,
}
#[test]
fn bindgen_test_layout_mycss_entry() {
    assert_eq!(::std::mem::size_of::<mycss_entry>() , 224usize , concat ! (
               "Size of: " , stringify ! ( mycss_entry ) ));
    assert_eq! (::std::mem::align_of::<mycss_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycss_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . mycss as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mycss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . token as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . stylesheet as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( stylesheet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . mchar as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mchar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . mchar_node_id as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mchar_node_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . mchar_value_node_id as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mchar_value_node_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . mcobject_string_entries
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mcobject_string_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . ns as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( ns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . selectors as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( selectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . anb as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( anb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . media as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . declaration as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( declaration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . values as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) .
                mcobject_incoming_buffer as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( mcobject_incoming_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . first_buffer as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( first_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . current_buffer as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( current_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . type_ as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . encoding as * const _
                as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( encoding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . state as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . state_back as * const _
                as usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( state_back ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser_list as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser_switch as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser_switch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser_error as * const
                _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser_original as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser_original ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . parser_ending_token as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( parser_ending_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . token_ready_callback as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( token_ready_callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . callback_selector_done
                as * const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( callback_selector_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . token_counter as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( token_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry ) ) . help_counter as * const
                _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry ) , "::" ,
                stringify ! ( help_counter ) ));
}
impl Clone for mycss_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_entry_t = mycss_entry;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_entry_type {
    MyCSS_ENTRY_TYPE_CLEAN = 0,
    MyCSS_ENTRY_TYPE_END = 1,
}
pub use self::mycss_entry_type as mycss_entry_type_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss {
    pub parse_state_func: *mut mycss_tokenizer_state_f,
}
#[test]
fn bindgen_test_layout_mycss() {
    assert_eq!(::std::mem::size_of::<mycss>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mycss ) ));
    assert_eq! (::std::mem::align_of::<mycss>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss ) ) . parse_state_func as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss ) , "::" ,
                stringify ! ( parse_state_func ) ));
}
impl Clone for mycss {
    fn clone(&self) -> Self { *self }
}
pub type mycss_t = mycss;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_token {
    pub type_: mycss_token_type_t,
    pub begin: usize,
    pub length: usize,
    pub data: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mycss_token() {
    assert_eq!(::std::mem::size_of::<mycss_token>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mycss_token ) ));
    assert_eq! (::std::mem::align_of::<mycss_token>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycss_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_token ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_token ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_token ) ) . begin as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_token ) , "::" ,
                stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_token ) ) . length as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_token ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_token ) ) . data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_token ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for mycss_token {
    fn clone(&self) -> Self { *self }
}
pub type mycss_token_t = mycss_token;
pub const mycss_tokenizer_state_MyCSS_TOKENIZER_STATE_FIRST_ENTRY:
          mycss_tokenizer_state =
    mycss_tokenizer_state::MyCSS_TOKENIZER_STATE_DATA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_tokenizer_state {
    MyCSS_TOKENIZER_STATE_DATA = 0,
    MyCSS_TOKENIZER_STATE_APOSTROPHE = 1,
    MyCSS_TOKENIZER_STATE_ASTERISK = 2,
    MyCSS_TOKENIZER_STATE_CIRCUMFLEX_ACCENT = 3,
    MyCSS_TOKENIZER_STATE_COLON = 4,
    MyCSS_TOKENIZER_STATE_COMMA = 5,
    MyCSS_TOKENIZER_STATE_COMMERCIAL_AT = 6,
    MyCSS_TOKENIZER_STATE_DELIM_SINGLE_CODE_POINT = 7,
    MyCSS_TOKENIZER_STATE_DIGIT = 8,
    MyCSS_TOKENIZER_STATE_DOLLAR_SIGN = 9,
    MyCSS_TOKENIZER_STATE_FULL_STOP = 10,
    MyCSS_TOKENIZER_STATE_HYPHEN_MINUS = 11,
    MyCSS_TOKENIZER_STATE_LEFT_CURLY_BRACKET = 12,
    MyCSS_TOKENIZER_STATE_LEFT_PARENTHESIS = 13,
    MyCSS_TOKENIZER_STATE_LEFT_SQUARE_BRACKET = 14,
    MyCSS_TOKENIZER_STATE_LESS_THAN_SIGN = 15,
    MyCSS_TOKENIZER_STATE_NAME_START_CODE_POINT = 16,
    MyCSS_TOKENIZER_STATE_NUMBER_SIGN = 17,
    MyCSS_TOKENIZER_STATE_PLUS_SIGN = 18,
    MyCSS_TOKENIZER_STATE_QUOTATION_MARK = 19,
    MyCSS_TOKENIZER_STATE_REVERSE_SOLIDUS = 20,
    MyCSS_TOKENIZER_STATE_RIGHT_CURLY_BRACKET = 21,
    MyCSS_TOKENIZER_STATE_RIGHT_PARENTHESIS = 22,
    MyCSS_TOKENIZER_STATE_RIGHT_SQUARE_BRACKET = 23,
    MyCSS_TOKENIZER_STATE_SEMICOLON = 24,
    MyCSS_TOKENIZER_STATE_SOLIDUS = 25,
    MyCSS_TOKENIZER_STATE_TILDE = 26,
    MyCSS_TOKENIZER_STATE_VERTICAL_LINE = 27,
    MyCSS_TOKENIZER_STATE_WHITESPACE = 28,
    MyCSS_TOKENIZER_STATE_QUOTATION_MARK_BACK = 29,
    MyCSS_TOKENIZER_STATE_NUMBER_SIGN_NAME_BACK = 30,
    MyCSS_TOKENIZER_STATE_NUMBER_SIGN_NAME_RSOLIDUS = 31,
    MyCSS_TOKENIZER_STATE_APOSTROPHE_BACK = 32,
    MyCSS_TOKENIZER_STATE_HYPHEN_MINUS_RSOLIDUS = 33,
    MyCSS_TOKENIZER_STATE_HYPHEN_MINUS_MINUS = 34,
    MyCSS_TOKENIZER_STATE_HYPHEN_MINUS_MINUS_RSOLIDUS = 35,
    MyCSS_TOKENIZER_STATE_HYPHEN_MINUS_FULL_STOP = 36,
    MyCSS_TOKENIZER_STATE_SOLIDUS_COMMENT_END = 37,
    MyCSS_TOKENIZER_STATE_COMMERCIAL_AT_RSOLIDUS = 38,
    MyCSS_TOKENIZER_STATE_COMMERCIAL_AT_BACK = 39,
    MyCSS_TOKENIZER_STATE_COMMERCIAL_AT_MINUS = 40,
    MyCSS_TOKENIZER_STATE_COMMERCIAL_AT_MINUS_RSOLIDUS = 41,
    MyCSS_TOKENIZER_STATE_LESS_THAN_SIGN_MINUS = 42,
    MyCSS_TOKENIZER_STATE_LESS_THAN_SIGN_MINUS_MINUS = 43,
    MyCSS_TOKENIZER_STATE_PLUS_SIGN_FULL_STOP = 44,
    MyCSS_TOKENIZER_STATE_LETTER_U = 45,
    MyCSS_TOKENIZER_STATE_LETTER_U_NEXT = 46,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_DIGIT = 80,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_DECIMAL = 81,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_DOT = 82,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_E = 83,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_E_PLUS_MINUS = 84,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMBER_E_DECIMAL = 85,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMERIC = 86,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMERIC_RSOLIDUS = 87,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMERIC_MINUS = 88,
    MyCSS_TOKENIZER_GLOBAL_STATE_NUMERIC_MINUS_RSOLIDUS = 89,
    MyCSS_TOKENIZER_GLOBAL_STATE_IDENT = 90,
    MyCSS_TOKENIZER_GLOBAL_STATE_URL = 91,
    MyCSS_TOKENIZER_GLOBAL_STATE_URL_STRING_BACK = 92,
    MyCSS_TOKENIZER_GLOBAL_STATE_URL_AFTER = 93,
    MyCSS_TOKENIZER_GLOBAL_STATE_URL_AFTER_WHITESPACE = 94,
    MyCSS_TOKENIZER_GLOBAL_STATE_URL_RSOLIDUS = 95,
    MyCSS_TOKENIZER_GLOBAL_STATE_BAD_URL = 96,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_DOUBLE_QUOTED = 97,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_DOUBLE_QUOTED_RSOLIDUS = 98,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_DOUBLE_QUOTED_RSOLIDUS_R = 99,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_SINGLE_QUOTED = 100,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_SINGLE_QUOTED_RSOLIDUS = 101,
    MyCSS_TOKENIZER_GLOBAL_STATE_STRING_SINGLE_QUOTED_RSOLIDUS_R = 102,
    MyCSS_TOKENIZER_GLOBAL_STATE_NAME = 103,
    MyCSS_TOKENIZER_GLOBAL_STATE_NAME_RSOLIDUS = 104,
    MyCSS_TOKENIZER_GLOBAL_STATE_UNICODE_RANGE_BEFORE = 105,
    MyCSS_TOKENIZER_GLOBAL_STATE_UNICODE_RANGE = 106,
    MyCSS_TOKENIZER_GLOBAL_STATE_UNICODE_RANGE_QUESTION = 107,
    MyCSS_TOKENIZER_GLOBAL_STATE_UNICODE_RANGE_MINUS = 108,
    MyCSS_TOKENIZER_GLOBAL_BACK = 128,
    MyCSS_TOKENIZER_STATE_LAST_ENTRY = 256,
}
pub use self::mycss_tokenizer_state as mycss_tokenizer_state_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_token_type {
    MyCSS_TOKEN_TYPE_UNDEF = 0,
    MyCSS_TOKEN_TYPE_WHITESPACE = 1,
    MyCSS_TOKEN_TYPE_IDENT = 2,
    MyCSS_TOKEN_TYPE_FUNCTION = 3,
    MyCSS_TOKEN_TYPE_AT_KEYWORD = 4,
    MyCSS_TOKEN_TYPE_HASH = 5,
    MyCSS_TOKEN_TYPE_STRING = 6,
    MyCSS_TOKEN_TYPE_URL = 7,
    MyCSS_TOKEN_TYPE_NUMBER = 8,
    MyCSS_TOKEN_TYPE_DIMENSION = 9,
    MyCSS_TOKEN_TYPE_PERCENTAGE = 10,
    MyCSS_TOKEN_TYPE_INCLUDE_MATCH = 11,
    MyCSS_TOKEN_TYPE_DASH_MATCH = 12,
    MyCSS_TOKEN_TYPE_PREFIX_MATCH = 13,
    MyCSS_TOKEN_TYPE_SUFFIX_MATCH = 14,
    MyCSS_TOKEN_TYPE_SUBSTRING_MATCH = 15,
    MyCSS_TOKEN_TYPE_COLUMN = 16,
    MyCSS_TOKEN_TYPE_CDO = 17,
    MyCSS_TOKEN_TYPE_CDC = 18,
    MyCSS_TOKEN_TYPE_BAD_STRING = 19,
    MyCSS_TOKEN_TYPE_DELIM = 20,
    MyCSS_TOKEN_TYPE_LEFT_PARENTHESIS = 21,
    MyCSS_TOKEN_TYPE_RIGHT_PARENTHESIS = 22,
    MyCSS_TOKEN_TYPE_COMMA = 23,
    MyCSS_TOKEN_TYPE_COLON = 24,
    MyCSS_TOKEN_TYPE_SEMICOLON = 25,
    MyCSS_TOKEN_TYPE_LEFT_SQUARE_BRACKET = 26,
    MyCSS_TOKEN_TYPE_RIGHT_SQUARE_BRACKET = 27,
    MyCSS_TOKEN_TYPE_LEFT_CURLY_BRACKET = 28,
    MyCSS_TOKEN_TYPE_RIGHT_CURLY_BRACKET = 29,
    MyCSS_TOKEN_TYPE_BAD_URL = 30,
    MyCSS_TOKEN_TYPE_COMMENT = 31,
    MyCSS_TOKEN_TYPE_UNICODE_RANGE = 32,
    MyCSS_TOKEN_TYPE_EOF = 33,
    MyCSS_TOKEN_TYPE_LAST_ENTRY = 34,
}
pub use self::mycss_token_type as mycss_token_type_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_an_plus_b {
    pub entry: *mut *mut mycss_an_plus_b_entry_t,
}
#[test]
fn bindgen_test_layout_mycss_an_plus_b() {
    assert_eq!(::std::mem::size_of::<mycss_an_plus_b>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mycss_an_plus_b ) ));
    assert_eq! (::std::mem::align_of::<mycss_an_plus_b>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mycss_an_plus_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b ) ) . entry as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b ) ,
                "::" , stringify ! ( entry ) ));
}
impl Clone for mycss_an_plus_b {
    fn clone(&self) -> Self { *self }
}
pub type mycss_an_plus_b_t = mycss_an_plus_b;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_an_plus_b_entry {
    pub a: ::std::os::raw::c_long,
    pub b: ::std::os::raw::c_long,
    pub n: ::std::os::raw::c_long,
    pub is_broken: bool,
    pub of: *mut mycss_selectors_list_t,
}
#[test]
fn bindgen_test_layout_mycss_an_plus_b_entry() {
    assert_eq!(::std::mem::size_of::<mycss_an_plus_b_entry>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( mycss_an_plus_b_entry )
               ));
    assert_eq! (::std::mem::align_of::<mycss_an_plus_b_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_an_plus_b_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b_entry ) ) . a as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b_entry )
                , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b_entry ) ) . b as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b_entry )
                , "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b_entry ) ) . n as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b_entry )
                , "::" , stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b_entry ) ) . is_broken as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b_entry )
                , "::" , stringify ! ( is_broken ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_an_plus_b_entry ) ) . of as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_an_plus_b_entry )
                , "::" , stringify ! ( of ) ));
}
impl Clone for mycss_an_plus_b_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_an_plus_b_entry_t = mycss_an_plus_b_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_stylesheet {
    pub entry: *mut mycss_entry_t,
    pub ns_stylesheet: mycss_namespace_stylesheet_t,
    pub sel_list_first: *mut mycss_selectors_list_t,
    pub child: *mut mycss_stylesheet_t,
    pub parent: *mut mycss_stylesheet_t,
    pub next: *mut mycss_stylesheet_t,
    pub prev: *mut mycss_stylesheet_t,
}
#[test]
fn bindgen_test_layout_mycss_stylesheet() {
    assert_eq!(::std::mem::size_of::<mycss_stylesheet>() , 176usize , concat !
               ( "Size of: " , stringify ! ( mycss_stylesheet ) ));
    assert_eq! (::std::mem::align_of::<mycss_stylesheet>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mycss_stylesheet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . entry as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . ns_stylesheet as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( ns_stylesheet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . sel_list_first as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( sel_list_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . child as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . parent as * const
                _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . next as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stylesheet ) ) . prev as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stylesheet ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for mycss_stylesheet {
    fn clone(&self) -> Self { *self }
}
pub type mycss_stylesheet_t = mycss_stylesheet;
pub type mycss_tokenizer_state_f =
    ::std::option::Option<unsafe extern "C" fn(entry: *mut mycss_entry_t,
                                               token: *mut mycss_token_t,
                                               css:
                                                   *const ::std::os::raw::c_char,
                                               css_offset: usize,
                                               css_size: usize) -> usize>;
pub type mycss_token_ready_callback_f =
    ::std::option::Option<unsafe extern "C" fn(entry: *mut mycss_entry_t,
                                               token: *mut mycss_token_t)
                              -> *mut mycss_token_t>;
pub type mycss_parser_token_f =
    ::std::option::Option<unsafe extern "C" fn(entry: *mut mycss_entry_t,
                                               token: *mut mycss_token_t,
                                               last_response: bool) -> bool>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcobject_chunk {
    pub begin: *mut ::std::os::raw::c_uchar,
    pub length: usize,
    pub size: usize,
    pub next: *mut mcobject_chunk,
    pub prev: *mut mcobject_chunk,
}
#[test]
fn bindgen_test_layout_mcobject_chunk() {
    assert_eq!(::std::mem::size_of::<mcobject_chunk>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mcobject_chunk ) ));
    assert_eq! (::std::mem::align_of::<mcobject_chunk>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcobject_chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject_chunk ) ) . begin as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject_chunk ) , "::"
                , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject_chunk ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject_chunk ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject_chunk ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject_chunk ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject_chunk ) ) . next as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject_chunk ) , "::"
                , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject_chunk ) ) . prev as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject_chunk ) , "::"
                , stringify ! ( prev ) ));
}
impl Clone for mcobject_chunk {
    fn clone(&self) -> Self { *self }
}
pub type mcobject_chunk_t = mcobject_chunk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcobject {
    pub chunk: *mut mcobject_chunk_t,
    pub cache: *mut *mut ::std::os::raw::c_void,
    pub cache_size: usize,
    pub cache_length: usize,
    pub struct_size: usize,
    pub chunk_size: usize,
}
#[test]
fn bindgen_test_layout_mcobject() {
    assert_eq!(::std::mem::size_of::<mcobject>() , 48usize , concat ! (
               "Size of: " , stringify ! ( mcobject ) ));
    assert_eq! (::std::mem::align_of::<mcobject>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcobject ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . chunk as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . cache as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . cache_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . cache_length as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( cache_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . struct_size as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( struct_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcobject ) ) . chunk_size as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mcobject ) , "::" ,
                stringify ! ( chunk_size ) ));
}
impl Clone for mcobject {
    fn clone(&self) -> Self { *self }
}
pub type mcobject_t = mcobject;
pub type mctree_index_t = usize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mctree_node {
    pub str: *const ::std::os::raw::c_char,
    pub str_size: usize,
    pub value: *mut ::std::os::raw::c_void,
    pub child_count: usize,
    pub prev: mctree_index_t,
    pub next: mctree_index_t,
    pub child: mctree_index_t,
}
#[test]
fn bindgen_test_layout_mctree_node() {
    assert_eq!(::std::mem::size_of::<mctree_node>() , 56usize , concat ! (
               "Size of: " , stringify ! ( mctree_node ) ));
    assert_eq! (::std::mem::align_of::<mctree_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mctree_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . str as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . str_size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( str_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . child_count as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( child_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . prev as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_node ) ) . child as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_node ) , "::" ,
                stringify ! ( child ) ));
}
impl Clone for mctree_node {
    fn clone(&self) -> Self { *self }
}
pub type mctree_node_t = mctree_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mctree_tree {
    pub nodes: *mut mctree_node_t,
    pub nodes_length: usize,
    pub nodes_size: usize,
    pub start_size: usize,
}
#[test]
fn bindgen_test_layout_mctree_tree() {
    assert_eq!(::std::mem::size_of::<mctree_tree>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mctree_tree ) ));
    assert_eq! (::std::mem::align_of::<mctree_tree>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mctree_tree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_tree ) ) . nodes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_tree ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_tree ) ) . nodes_length as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_tree ) , "::" ,
                stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_tree ) ) . nodes_size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_tree ) , "::" ,
                stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mctree_tree ) ) . start_size as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mctree_tree ) , "::" ,
                stringify ! ( start_size ) ));
}
impl Clone for mctree_tree {
    fn clone(&self) -> Self { *self }
}
pub type mctree_t = mctree_tree;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcsync {
    pub spinlock: *mut ::std::os::raw::c_int,
    pub mutex: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mcsync() {
    assert_eq!(::std::mem::size_of::<mcsync>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mcsync ) ));
    assert_eq! (::std::mem::align_of::<mcsync>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcsync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . spinlock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( spinlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . mutex as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for mcsync {
    fn clone(&self) -> Self { *self }
}
pub type mcsync_t = mcsync;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_node {
    pub chunk: *mut mchar_async_chunk_t,
    pub cache: mchar_async_cache_t,
}
#[test]
fn bindgen_test_layout_mchar_async_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_node>() , 72usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_node ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mchar_async_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . chunk as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . cache as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( cache ) ));
}
impl Clone for mchar_async_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_node_t = mchar_async_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache_node {
    pub value: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub left: usize,
    pub right: usize,
    pub parent: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache_node>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( mchar_async_cache_node )
               ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache_node>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mchar_async_cache_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . left as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . right as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . parent as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( parent ) ));
}
impl Clone for mchar_async_cache_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_node_t = mchar_async_cache_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_chunk {
    pub begin: *mut ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub next: *mut mchar_async_chunk,
    pub prev: *mut mchar_async_chunk,
}
#[test]
fn bindgen_test_layout_mchar_async_chunk() {
    assert_eq!(::std::mem::size_of::<mchar_async_chunk>() , 40usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_chunk>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . begin as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . length as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . next as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . prev as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for mchar_async_chunk {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_chunk_t = mchar_async_chunk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache {
    pub nodes: *mut mchar_async_cache_node_t,
    pub nodes_size: usize,
    pub nodes_length: usize,
    pub nodes_root: usize,
    pub count: usize,
    pub index: *mut usize,
    pub index_length: usize,
    pub index_size: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache>() , 64usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_root as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . count as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_size ) ));
}
impl Clone for mchar_async_cache {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_t = mchar_async_cache;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async {
    pub origin_size: usize,
    pub chunks: *mut *mut mchar_async_chunk_t,
    pub chunks_pos_size: usize,
    pub chunks_pos_length: usize,
    pub chunks_size: usize,
    pub chunks_length: usize,
    pub chunk_cache: mchar_async_cache_t,
    pub nodes: *mut mchar_async_node_t,
    pub nodes_length: usize,
    pub nodes_size: usize,
    pub nodes_cache: *mut usize,
    pub nodes_cache_length: usize,
    pub nodes_cache_size: usize,
    pub mcsync: *mut mcsync_t,
}
#[test]
fn bindgen_test_layout_mchar_async() {
    assert_eq!(::std::mem::size_of::<mchar_async>() , 168usize , concat ! (
               "Size of: " , stringify ! ( mchar_async ) ));
    assert_eq! (::std::mem::align_of::<mchar_async>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mchar_async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . origin_size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( origin_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_length as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_length as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunk_cache as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunk_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_length as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_size as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_length as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_size as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . mcsync as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( mcsync ) ));
}
impl Clone for mchar_async {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_t = mchar_async;
pub const myencoding_list_MyENCODING_UTF_8: myencoding_list =
    myencoding_list::MyENCODING_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myencoding_list {
    MyENCODING_DEFAULT = 0,
    MyENCODING_NOT_DETERMINED = 2,
    MyENCODING_UTF_16LE = 4,
    MyENCODING_UTF_16BE = 5,
    MyENCODING_X_USER_DEFINED = 6,
    MyENCODING_BIG5 = 7,
    MyENCODING_EUC_JP = 8,
    MyENCODING_EUC_KR = 9,
    MyENCODING_GB18030 = 10,
    MyENCODING_GBK = 11,
    MyENCODING_IBM866 = 12,
    MyENCODING_ISO_2022_JP = 13,
    MyENCODING_ISO_8859_10 = 14,
    MyENCODING_ISO_8859_13 = 15,
    MyENCODING_ISO_8859_14 = 16,
    MyENCODING_ISO_8859_15 = 17,
    MyENCODING_ISO_8859_16 = 18,
    MyENCODING_ISO_8859_2 = 19,
    MyENCODING_ISO_8859_3 = 20,
    MyENCODING_ISO_8859_4 = 21,
    MyENCODING_ISO_8859_5 = 22,
    MyENCODING_ISO_8859_6 = 23,
    MyENCODING_ISO_8859_7 = 24,
    MyENCODING_ISO_8859_8 = 25,
    MyENCODING_ISO_8859_8_I = 26,
    MyENCODING_KOI8_R = 27,
    MyENCODING_KOI8_U = 28,
    MyENCODING_MACINTOSH = 29,
    MyENCODING_SHIFT_JIS = 30,
    MyENCODING_WINDOWS_1250 = 31,
    MyENCODING_WINDOWS_1251 = 32,
    MyENCODING_WINDOWS_1252 = 33,
    MyENCODING_WINDOWS_1253 = 34,
    MyENCODING_WINDOWS_1254 = 35,
    MyENCODING_WINDOWS_1255 = 36,
    MyENCODING_WINDOWS_1256 = 37,
    MyENCODING_WINDOWS_1257 = 38,
    MyENCODING_WINDOWS_1258 = 39,
    MyENCODING_WINDOWS_874 = 40,
    MyENCODING_X_MAC_CYRILLIC = 41,
    MyENCODING_LAST_ENTRY = 42,
}
pub use self::myencoding_list as myencoding_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_namespace {
    pub entry: *mut *mut mycss_namespace_entry_t,
    pub entry_last: *mut mycss_namespace_entry_t,
    pub ns_stylesheet: *mut mycss_namespace_stylesheet_t,
    pub mcobject_entries: *mut mcobject_t,
}
#[test]
fn bindgen_test_layout_mycss_namespace() {
    assert_eq!(::std::mem::size_of::<mycss_namespace>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mycss_namespace ) ));
    assert_eq! (::std::mem::align_of::<mycss_namespace>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mycss_namespace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace ) ) . entry as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace ) ) . entry_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace ) ,
                "::" , stringify ! ( entry_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace ) ) . ns_stylesheet as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace ) ,
                "::" , stringify ! ( ns_stylesheet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace ) ) . mcobject_entries as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace ) ,
                "::" , stringify ! ( mcobject_entries ) ));
}
impl Clone for mycss_namespace {
    fn clone(&self) -> Self { *self }
}
pub type mycss_namespace_t = mycss_namespace;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_namespace_entry {
    pub name: *mut mycore_string_t,
    pub url: *mut mycore_string_t,
    pub ns_id: myhtml_namespace_t,
    pub mctree_id: usize,
    pub next: *mut mycss_namespace_entry_t,
    pub prev: *mut mycss_namespace_entry_t,
}
#[test]
fn bindgen_test_layout_mycss_namespace_entry() {
    assert_eq!(::std::mem::size_of::<mycss_namespace_entry>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( mycss_namespace_entry )
               ));
    assert_eq! (::std::mem::align_of::<mycss_namespace_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_namespace_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . url as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( url ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . ns_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( ns_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . mctree_id as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( mctree_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . next as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_entry ) ) . prev as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_namespace_entry )
                , "::" , stringify ! ( prev ) ));
}
impl Clone for mycss_namespace_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_namespace_entry_t = mycss_namespace_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_namespace_stylesheet {
    pub name_tree: *mut mctree_t,
    pub entry_first: *mut mycss_namespace_entry_t,
    pub entry_default: *mut mycss_namespace_entry_t,
    pub entry_undef: mycss_namespace_entry_t,
    pub entry_any: mycss_namespace_entry_t,
    pub ns_id_counter: usize,
}
#[test]
fn bindgen_test_layout_mycss_namespace_stylesheet() {
    assert_eq!(::std::mem::size_of::<mycss_namespace_stylesheet>() , 128usize
               , concat ! (
               "Size of: " , stringify ! ( mycss_namespace_stylesheet ) ));
    assert_eq! (::std::mem::align_of::<mycss_namespace_stylesheet>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( mycss_namespace_stylesheet )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                name_tree as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! ( name_tree
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                entry_first as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! (
                entry_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                entry_default as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! (
                entry_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                entry_undef as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! (
                entry_undef ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                entry_any as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! ( entry_any
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_namespace_stylesheet ) ) .
                ns_id_counter as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_namespace_stylesheet ) , "::" , stringify ! (
                ns_id_counter ) ));
}
impl Clone for mycss_namespace_stylesheet {
    fn clone(&self) -> Self { *self }
}
pub type mycss_namespace_stylesheet_t = mycss_namespace_stylesheet;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_selectors {
    pub ref_entry: *mut mycss_entry_t,
    pub entry: *mut *mut mycss_selectors_entry_t,
    pub entry_last: *mut mycss_selectors_entry_t,
    pub list: *mut *mut mycss_selectors_list_t,
    pub list_last: *mut mycss_selectors_list_t,
    pub specificity: *mut mycss_selectors_specificity_t,
    pub combinator: *mut mycss_selectors_combinator_t,
    pub ending_token: mycss_token_type_t,
    pub mcobject_entries: *mut mcobject_t,
    pub mcobject_list_entries: *mut mcobject_t,
}
#[test]
fn bindgen_test_layout_mycss_selectors() {
    assert_eq!(::std::mem::size_of::<mycss_selectors>() , 80usize , concat ! (
               "Size of: " , stringify ! ( mycss_selectors ) ));
    assert_eq! (::std::mem::align_of::<mycss_selectors>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mycss_selectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . ref_entry as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( ref_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . entry as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . entry_last as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( entry_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . list as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . list_last as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( list_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . specificity as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( specificity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . combinator as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( combinator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . ending_token as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( ending_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) . mcobject_entries as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( mcobject_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors ) ) .
                mcobject_list_entries as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors ) ,
                "::" , stringify ! ( mcobject_list_entries ) ));
}
impl Clone for mycss_selectors {
    fn clone(&self) -> Self { *self }
}
pub type mycss_selectors_t = mycss_selectors;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_selectors_entry {
    pub type_: mycss_selectors_type_t,
    pub sub_type: ::std::os::raw::c_uint,
    pub flags: mycss_selectors_flags_t,
    pub ns_entry: *mut mycss_namespace_entry_t,
    pub key: *mut mycore_string_t,
    pub value: *mut ::std::os::raw::c_void,
    pub combinator: mycss_selectors_combinator_t,
    pub next: *mut mycss_selectors_entry_t,
    pub prev: *mut mycss_selectors_entry_t,
}
#[test]
fn bindgen_test_layout_mycss_selectors_entry() {
    assert_eq!(::std::mem::size_of::<mycss_selectors_entry>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( mycss_selectors_entry )
               ));
    assert_eq! (::std::mem::align_of::<mycss_selectors_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_selectors_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . sub_type as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( sub_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . ns_entry as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( ns_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . key as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . value as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . combinator as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( combinator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . next as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entry ) ) . prev as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_entry )
                , "::" , stringify ! ( prev ) ));
}
impl Clone for mycss_selectors_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_selectors_entry_t = mycss_selectors_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_selectors_entries_list {
    pub entry: *mut mycss_selectors_entry_t,
    pub specificity: mycss_selectors_specificity_t,
}
#[test]
fn bindgen_test_layout_mycss_selectors_entries_list() {
    assert_eq!(::std::mem::size_of::<mycss_selectors_entries_list>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( mycss_selectors_entries_list ) ));
    assert_eq! (::std::mem::align_of::<mycss_selectors_entries_list>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( mycss_selectors_entries_list )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entries_list ) ) . entry
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_selectors_entries_list ) , "::" , stringify ! ( entry )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_entries_list ) ) .
                specificity as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_selectors_entries_list ) , "::" , stringify ! (
                specificity ) ));
}
impl Clone for mycss_selectors_entries_list {
    fn clone(&self) -> Self { *self }
}
pub type mycss_selectors_entries_list_t = mycss_selectors_entries_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_selectors_list {
    pub entries_list: *mut mycss_selectors_entries_list_t,
    pub entries_list_length: usize,
    pub declaration_entry: *mut mycss_declaration_entry_t,
    pub flags: mycss_selectors_flags_t,
    pub parent: *mut mycss_selectors_list_t,
    pub next: *mut mycss_selectors_list_t,
    pub prev: *mut mycss_selectors_list_t,
}
#[test]
fn bindgen_test_layout_mycss_selectors_list() {
    assert_eq!(::std::mem::size_of::<mycss_selectors_list>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( mycss_selectors_list )
               ));
    assert_eq! (::std::mem::align_of::<mycss_selectors_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_selectors_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) . entries_list
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( entries_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) .
                entries_list_length as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( entries_list_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) .
                declaration_entry as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( declaration_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) . flags as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) . parent as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) . next as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_list ) ) . prev as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_selectors_list )
                , "::" , stringify ! ( prev ) ));
}
impl Clone for mycss_selectors_list {
    fn clone(&self) -> Self { *self }
}
pub type mycss_selectors_list_t = mycss_selectors_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_selectors_specificity {
    pub a: ::std::os::raw::c_uint,
    pub b: ::std::os::raw::c_uint,
    pub c: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mycss_selectors_specificity() {
    assert_eq!(::std::mem::size_of::<mycss_selectors_specificity>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( mycss_selectors_specificity ) ));
    assert_eq! (::std::mem::align_of::<mycss_selectors_specificity>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( mycss_selectors_specificity )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_specificity ) ) . a as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_selectors_specificity ) , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_specificity ) ) . b as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_selectors_specificity ) , "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_selectors_specificity ) ) . c as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_selectors_specificity ) , "::" , stringify ! ( c ) ));
}
impl Clone for mycss_selectors_specificity {
    fn clone(&self) -> Self { *self }
}
pub type mycss_selectors_specificity_t = mycss_selectors_specificity;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_stack_entry {
    pub value: *mut ::std::os::raw::c_void,
    pub parser: mycss_parser_token_f,
}
#[test]
fn bindgen_test_layout_mycss_stack_entry() {
    assert_eq!(::std::mem::size_of::<mycss_stack_entry>() , 16usize , concat !
               ( "Size of: " , stringify ! ( mycss_stack_entry ) ));
    assert_eq! (::std::mem::align_of::<mycss_stack_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mycss_stack_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stack_entry ) ) . value as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stack_entry ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stack_entry ) ) . parser as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stack_entry ) ,
                "::" , stringify ! ( parser ) ));
}
impl Clone for mycss_stack_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_stack_entry_t = mycss_stack_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_stack {
    pub entries: *mut mycss_stack_entry_t,
    pub entries_length: usize,
    pub entries_size: usize,
}
#[test]
fn bindgen_test_layout_mycss_stack() {
    assert_eq!(::std::mem::size_of::<mycss_stack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mycss_stack ) ));
    assert_eq! (::std::mem::align_of::<mycss_stack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycss_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stack ) ) . entries as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stack ) , "::" ,
                stringify ! ( entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stack ) ) . entries_length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stack ) , "::" ,
                stringify ! ( entries_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_stack ) ) . entries_size as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_stack ) , "::" ,
                stringify ! ( entries_size ) ));
}
impl Clone for mycss_stack {
    fn clone(&self) -> Self { *self }
}
pub type mycss_stack_t = mycss_stack;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_property_type {
    MyCSS_PROPERTY_TYPE_UNDEF = 0,
    MyCSS_PROPERTY_TYPE_ALIGN_CONTENT = 1,
    MyCSS_PROPERTY_TYPE_ALIGN_ITEMS = 2,
    MyCSS_PROPERTY_TYPE_ALIGN_SELF = 3,
    MyCSS_PROPERTY_TYPE_ANIMATION = 4,
    MyCSS_PROPERTY_TYPE_ANIMATION_DELAY = 5,
    MyCSS_PROPERTY_TYPE_ANIMATION_DIRECTION = 6,
    MyCSS_PROPERTY_TYPE_ANIMATION_DURATION = 7,
    MyCSS_PROPERTY_TYPE_ANIMATION_FILL_MODE = 8,
    MyCSS_PROPERTY_TYPE_ANIMATION_ITERATION_COUNT = 9,
    MyCSS_PROPERTY_TYPE_ANIMATION_NAME = 10,
    MyCSS_PROPERTY_TYPE_ANIMATION_PLAY_STATE = 11,
    MyCSS_PROPERTY_TYPE_ANIMATION_TIMING_FUNCTION = 12,
    MyCSS_PROPERTY_TYPE_APPEARANCE = 13,
    MyCSS_PROPERTY_TYPE_BACKFACE_VISIBILITY = 14,
    MyCSS_PROPERTY_TYPE_BACKGROUND = 15,
    MyCSS_PROPERTY_TYPE_BACKGROUND_ATTACHMENT = 16,
    MyCSS_PROPERTY_TYPE_BACKGROUND_CLIP = 17,
    MyCSS_PROPERTY_TYPE_BACKGROUND_COLOR = 18,
    MyCSS_PROPERTY_TYPE_BACKGROUND_IMAGE = 19,
    MyCSS_PROPERTY_TYPE_BACKGROUND_ORIGIN = 20,
    MyCSS_PROPERTY_TYPE_BACKGROUND_POSITION = 21,
    MyCSS_PROPERTY_TYPE_BACKGROUND_REPEAT = 22,
    MyCSS_PROPERTY_TYPE_BACKGROUND_SIZE = 23,
    MyCSS_PROPERTY_TYPE_BOOKMARK_LABEL = 24,
    MyCSS_PROPERTY_TYPE_BOOKMARK_LEVEL = 25,
    MyCSS_PROPERTY_TYPE_BOOKMARK_STATE = 26,
    MyCSS_PROPERTY_TYPE_BORDER = 27,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_END = 28,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_END_COLOR = 29,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_END_STYLE = 30,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_END_WIDTH = 31,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_START = 32,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_START_COLOR = 33,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_START_STYLE = 34,
    MyCSS_PROPERTY_TYPE_BORDER_BLOCK_START_WIDTH = 35,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM = 36,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM_COLOR = 37,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM_LEFT_RADIUS = 38,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM_RIGHT_RADIUS = 39,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM_STYLE = 40,
    MyCSS_PROPERTY_TYPE_BORDER_BOTTOM_WIDTH = 41,
    MyCSS_PROPERTY_TYPE_BORDER_COLLAPSE = 42,
    MyCSS_PROPERTY_TYPE_BORDER_COLOR = 43,
    MyCSS_PROPERTY_TYPE_BORDER_IMAGE = 44,
    MyCSS_PROPERTY_TYPE_BORDER_IMAGE_OUTSET = 45,
    MyCSS_PROPERTY_TYPE_BORDER_IMAGE_REPEAT = 46,
    MyCSS_PROPERTY_TYPE_BORDER_IMAGE_SLICE = 47,
    MyCSS_PROPERTY_TYPE_BORDER_IMAGE_WIDTH = 48,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_END = 49,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_END_COLOR = 50,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_END_STYLE = 51,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_END_WIDTH = 52,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_START = 53,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_START_COLOR = 54,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_START_STYLE = 55,
    MyCSS_PROPERTY_TYPE_BORDER_INLINE_START_WIDTH = 56,
    MyCSS_PROPERTY_TYPE_BORDER_LEFT = 57,
    MyCSS_PROPERTY_TYPE_BORDER_LEFT_COLOR = 58,
    MyCSS_PROPERTY_TYPE_BORDER_LEFT_STYLE = 59,
    MyCSS_PROPERTY_TYPE_BORDER_LEFT_WIDTH = 60,
    MyCSS_PROPERTY_TYPE_BORDER_RADIUS = 61,
    MyCSS_PROPERTY_TYPE_BORDER_RIGHT = 62,
    MyCSS_PROPERTY_TYPE_BORDER_RIGHT_COLOR = 63,
    MyCSS_PROPERTY_TYPE_BORDER_RIGHT_STYLE = 64,
    MyCSS_PROPERTY_TYPE_BORDER_RIGHT_WIDTH = 65,
    MyCSS_PROPERTY_TYPE_BORDER_SPACING = 66,
    MyCSS_PROPERTY_TYPE_BORDER_STYLE = 67,
    MyCSS_PROPERTY_TYPE_BORDER_TOP = 68,
    MyCSS_PROPERTY_TYPE_BORDER_TOP_COLOR = 69,
    MyCSS_PROPERTY_TYPE_BORDER_TOP_LEFT_RADIUS = 70,
    MyCSS_PROPERTY_TYPE_BORDER_TOP_RIGHT_RADIUS = 71,
    MyCSS_PROPERTY_TYPE_BORDER_TOP_STYLE = 72,
    MyCSS_PROPERTY_TYPE_BORDER_TOP_WIDTH = 73,
    MyCSS_PROPERTY_TYPE_BORDER_WIDTH = 74,
    MyCSS_PROPERTY_TYPE_BOTTOM = 75,
    MyCSS_PROPERTY_TYPE_BOX_DECORATION_BREAK = 76,
    MyCSS_PROPERTY_TYPE_BOX_SHADOW = 77,
    MyCSS_PROPERTY_TYPE_BOX_SIZING = 78,
    MyCSS_PROPERTY_TYPE_BOX_SUPPRESS = 79,
    MyCSS_PROPERTY_TYPE_BREAK_AFTER = 80,
    MyCSS_PROPERTY_TYPE_BREAK_BEFORE = 81,
    MyCSS_PROPERTY_TYPE_BREAK_INSIDE = 82,
    MyCSS_PROPERTY_TYPE_CAPTION_SIDE = 83,
    MyCSS_PROPERTY_TYPE_CARET = 84,
    MyCSS_PROPERTY_TYPE_CARET_COLOR = 85,
    MyCSS_PROPERTY_TYPE_CARET_SHAPE = 86,
    MyCSS_PROPERTY_TYPE_CLEAR = 87,
    MyCSS_PROPERTY_TYPE_CLEAR_AFTER = 88,
    MyCSS_PROPERTY_TYPE_COLOR = 89,
    MyCSS_PROPERTY_TYPE_COLOR_ADJUST = 90,
    MyCSS_PROPERTY_TYPE_COLOR_INTERPOLATION = 91,
    MyCSS_PROPERTY_TYPE_COLOR_INTERPOLATION_FILTERS = 92,
    MyCSS_PROPERTY_TYPE_COLOR_RENDERING = 93,
    MyCSS_PROPERTY_TYPE_COLUMN_COUNT = 94,
    MyCSS_PROPERTY_TYPE_COLUMN_FILL = 95,
    MyCSS_PROPERTY_TYPE_COLUMN_GAP = 96,
    MyCSS_PROPERTY_TYPE_COLUMN_RULE = 97,
    MyCSS_PROPERTY_TYPE_COLUMN_RULE_COLOR = 98,
    MyCSS_PROPERTY_TYPE_COLUMN_RULE_STYLE = 99,
    MyCSS_PROPERTY_TYPE_COLUMN_RULE_WIDTH = 100,
    MyCSS_PROPERTY_TYPE_COLUMN_SPAN = 101,
    MyCSS_PROPERTY_TYPE_COLUMN_WIDTH = 102,
    MyCSS_PROPERTY_TYPE_COLUMNS = 103,
    MyCSS_PROPERTY_TYPE_CONTAIN = 104,
    MyCSS_PROPERTY_TYPE_CONTENT = 105,
    MyCSS_PROPERTY_TYPE_CONTINUE = 106,
    MyCSS_PROPERTY_TYPE_COUNTER_INCREMENT = 107,
    MyCSS_PROPERTY_TYPE_CUE = 108,
    MyCSS_PROPERTY_TYPE_CUE_AFTER = 109,
    MyCSS_PROPERTY_TYPE_CUE_BEFORE = 110,
    MyCSS_PROPERTY_TYPE_CURSOR = 111,
    MyCSS_PROPERTY_TYPE_DIRECTION = 112,
    MyCSS_PROPERTY_TYPE_DISPLAY = 113,
    MyCSS_PROPERTY_TYPE_EMPTY_CELLS = 114,
    MyCSS_PROPERTY_TYPE_FILL = 115,
    MyCSS_PROPERTY_TYPE_FILL_OPACITY = 116,
    MyCSS_PROPERTY_TYPE_FILL_RULE = 117,
    MyCSS_PROPERTY_TYPE_FLEX = 118,
    MyCSS_PROPERTY_TYPE_FLEX_BASIS = 119,
    MyCSS_PROPERTY_TYPE_FLEX_DIRECTION = 120,
    MyCSS_PROPERTY_TYPE_FLEX_FLOW = 121,
    MyCSS_PROPERTY_TYPE_FLEX_GROW = 122,
    MyCSS_PROPERTY_TYPE_FLEX_SHRINK = 123,
    MyCSS_PROPERTY_TYPE_FLEX_WRAP = 124,
    MyCSS_PROPERTY_TYPE_FLOAT = 125,
    MyCSS_PROPERTY_TYPE_FLOAT_DISPLACE = 126,
    MyCSS_PROPERTY_TYPE_FONT = 127,
    MyCSS_PROPERTY_TYPE_FONT_FAMILY = 128,
    MyCSS_PROPERTY_TYPE_FONT_FEATURE_SETTINGS = 129,
    MyCSS_PROPERTY_TYPE_FONT_KERNING = 130,
    MyCSS_PROPERTY_TYPE_FONT_LANGUAGE_OVERRIDE = 131,
    MyCSS_PROPERTY_TYPE_FONT_SIZE = 132,
    MyCSS_PROPERTY_TYPE_FONT_SIZE_ADJUST = 133,
    MyCSS_PROPERTY_TYPE_FONT_STRETCH = 134,
    MyCSS_PROPERTY_TYPE_FONT_STYLE = 135,
    MyCSS_PROPERTY_TYPE_FONT_SYNTHESIS = 136,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT = 137,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_ALTERNATES = 138,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_CAPS = 139,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_EAST_ASIAN = 140,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_LIGATURES = 141,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_NUMERIC = 142,
    MyCSS_PROPERTY_TYPE_FONT_VARIANT_POSITION = 143,
    MyCSS_PROPERTY_TYPE_FONT_WEIGHT = 144,
    MyCSS_PROPERTY_TYPE_GLYPH_ORIENTATION_VERTICAL = 145,
    MyCSS_PROPERTY_TYPE_HANGING_PUNCTUATION = 146,
    MyCSS_PROPERTY_TYPE_HEIGHT = 147,
    MyCSS_PROPERTY_TYPE_HYPHENS = 148,
    MyCSS_PROPERTY_TYPE_IMAGE_RENDERING = 149,
    MyCSS_PROPERTY_TYPE_INDENT_EDGE_RESET = 150,
    MyCSS_PROPERTY_TYPE_INLINE_SIZE_STEP = 151,
    MyCSS_PROPERTY_TYPE_JUSTIFY_CONTENT = 152,
    MyCSS_PROPERTY_TYPE_LEFT = 153,
    MyCSS_PROPERTY_TYPE_LETTER_SPACING = 154,
    MyCSS_PROPERTY_TYPE_LINE_BREAK = 155,
    MyCSS_PROPERTY_TYPE_LINE_HEIGHT = 156,
    MyCSS_PROPERTY_TYPE_LINE_HEIGHT_STEP = 157,
    MyCSS_PROPERTY_TYPE_LIST_STYLE = 158,
    MyCSS_PROPERTY_TYPE_LIST_STYLE_IMAGE = 159,
    MyCSS_PROPERTY_TYPE_LIST_STYLE_POSITION = 160,
    MyCSS_PROPERTY_TYPE_LIST_STYLE_TYPE = 161,
    MyCSS_PROPERTY_TYPE_MARGIN = 162,
    MyCSS_PROPERTY_TYPE_MARGIN_BLOCK_END = 163,
    MyCSS_PROPERTY_TYPE_MARGIN_BLOCK_START = 164,
    MyCSS_PROPERTY_TYPE_MARGIN_BOTTOM = 165,
    MyCSS_PROPERTY_TYPE_MARGIN_INLINE_END = 166,
    MyCSS_PROPERTY_TYPE_MARGIN_INLINE_START = 167,
    MyCSS_PROPERTY_TYPE_MARGIN_LEFT = 168,
    MyCSS_PROPERTY_TYPE_MARGIN_RIGHT = 169,
    MyCSS_PROPERTY_TYPE_MARGIN_TOP = 170,
    MyCSS_PROPERTY_TYPE_MARKER = 171,
    MyCSS_PROPERTY_TYPE_MARKER_END = 172,
    MyCSS_PROPERTY_TYPE_MARKER_MID = 173,
    MyCSS_PROPERTY_TYPE_MARKER_SIDE = 174,
    MyCSS_PROPERTY_TYPE_MARKER_START = 175,
    MyCSS_PROPERTY_TYPE_MAX_HEIGHT = 176,
    MyCSS_PROPERTY_TYPE_MAX_LINES = 177,
    MyCSS_PROPERTY_TYPE_MAX_WIDTH = 178,
    MyCSS_PROPERTY_TYPE_MIN_HEIGHT = 179,
    MyCSS_PROPERTY_TYPE_MIN_WIDTH = 180,
    MyCSS_PROPERTY_TYPE_NAV_DOWN = 181,
    MyCSS_PROPERTY_TYPE_NAV_LEFT = 182,
    MyCSS_PROPERTY_TYPE_NAV_RIGHT = 183,
    MyCSS_PROPERTY_TYPE_NAV_UP = 184,
    MyCSS_PROPERTY_TYPE_OFFSET_AFTER = 185,
    MyCSS_PROPERTY_TYPE_OFFSET_BEFORE = 186,
    MyCSS_PROPERTY_TYPE_OFFSET_END = 187,
    MyCSS_PROPERTY_TYPE_OFFSET_START = 188,
    MyCSS_PROPERTY_TYPE_OPACITY = 189,
    MyCSS_PROPERTY_TYPE_ORDER = 190,
    MyCSS_PROPERTY_TYPE_ORPHANS = 191,
    MyCSS_PROPERTY_TYPE_OUTLINE = 192,
    MyCSS_PROPERTY_TYPE_OUTLINE_COLOR = 193,
    MyCSS_PROPERTY_TYPE_OUTLINE_OFFSET = 194,
    MyCSS_PROPERTY_TYPE_OUTLINE_STYLE = 195,
    MyCSS_PROPERTY_TYPE_OUTLINE_WIDTH = 196,
    MyCSS_PROPERTY_TYPE_OVERFLOW = 197,
    MyCSS_PROPERTY_TYPE_OVERFLOW_WRAP = 198,
    MyCSS_PROPERTY_TYPE_OVERFLOW_X = 199,
    MyCSS_PROPERTY_TYPE_OVERFLOW_Y = 200,
    MyCSS_PROPERTY_TYPE_PADDING = 201,
    MyCSS_PROPERTY_TYPE_PADDING_BLOCK_END = 202,
    MyCSS_PROPERTY_TYPE_PADDING_BLOCK_START = 203,
    MyCSS_PROPERTY_TYPE_PADDING_BOTTOM = 204,
    MyCSS_PROPERTY_TYPE_PADDING_INLINE_END = 205,
    MyCSS_PROPERTY_TYPE_PADDING_INLINE_START = 206,
    MyCSS_PROPERTY_TYPE_PADDING_LEFT = 207,
    MyCSS_PROPERTY_TYPE_PADDING_RIGHT = 208,
    MyCSS_PROPERTY_TYPE_PADDING_TOP = 209,
    MyCSS_PROPERTY_TYPE_PAUSE = 210,
    MyCSS_PROPERTY_TYPE_PAUSE_AFTER = 211,
    MyCSS_PROPERTY_TYPE_PAUSE_BEFORE = 212,
    MyCSS_PROPERTY_TYPE_PERSPECTIVE = 213,
    MyCSS_PROPERTY_TYPE_PERSPECTIVE_ORIGIN = 214,
    MyCSS_PROPERTY_TYPE_POSITION = 215,
    MyCSS_PROPERTY_TYPE_PRESENTATION_LEVEL = 216,
    MyCSS_PROPERTY_TYPE_QUOTES = 217,
    MyCSS_PROPERTY_TYPE_REGION_FRAGMENT = 218,
    MyCSS_PROPERTY_TYPE_RESIZE = 219,
    MyCSS_PROPERTY_TYPE_REST = 220,
    MyCSS_PROPERTY_TYPE_REST_AFTER = 221,
    MyCSS_PROPERTY_TYPE_REST_BEFORE = 222,
    MyCSS_PROPERTY_TYPE_RIGHT = 223,
    MyCSS_PROPERTY_TYPE_RUBY_ALIGN = 224,
    MyCSS_PROPERTY_TYPE_RUBY_MERGE = 225,
    MyCSS_PROPERTY_TYPE_RUBY_POSITION = 226,
    MyCSS_PROPERTY_TYPE_SCROLL_PADDING = 227,
    MyCSS_PROPERTY_TYPE_SCROLL_SNAP_ALIGN = 228,
    MyCSS_PROPERTY_TYPE_SCROLL_SNAP_MARGIN = 229,
    MyCSS_PROPERTY_TYPE_SCROLL_SNAP_STOP = 230,
    MyCSS_PROPERTY_TYPE_SCROLL_SNAP_TYPE = 231,
    MyCSS_PROPERTY_TYPE_SHAPE_IMAGE_THRESHOLD = 232,
    MyCSS_PROPERTY_TYPE_SHAPE_MARGIN = 233,
    MyCSS_PROPERTY_TYPE_SHAPE_OUTSIDE = 234,
    MyCSS_PROPERTY_TYPE_SHAPE_RENDERING = 235,
    MyCSS_PROPERTY_TYPE_SPEAK = 236,
    MyCSS_PROPERTY_TYPE_SPEAK_AS = 237,
    MyCSS_PROPERTY_TYPE_STRING_SET = 238,
    MyCSS_PROPERTY_TYPE_STROKE = 239,
    MyCSS_PROPERTY_TYPE_STROKE_DASHARRAY = 240,
    MyCSS_PROPERTY_TYPE_STROKE_DASHOFFSET = 241,
    MyCSS_PROPERTY_TYPE_STROKE_LINECAP = 242,
    MyCSS_PROPERTY_TYPE_STROKE_LINEJOIN = 243,
    MyCSS_PROPERTY_TYPE_STROKE_MITERLIMIT = 244,
    MyCSS_PROPERTY_TYPE_STROKE_OPACITY = 245,
    MyCSS_PROPERTY_TYPE_STROKE_WIDTH = 246,
    MyCSS_PROPERTY_TYPE_TAB_SIZE = 247,
    MyCSS_PROPERTY_TYPE_TABLE_LAYOUT = 248,
    MyCSS_PROPERTY_TYPE_TEXT_ALIGN = 249,
    MyCSS_PROPERTY_TYPE_TEXT_ALIGN_ALL = 250,
    MyCSS_PROPERTY_TYPE_TEXT_ALIGN_LAST = 251,
    MyCSS_PROPERTY_TYPE_TEXT_COMBINE_UPRIGHT = 252,
    MyCSS_PROPERTY_TYPE_TEXT_DECORATION = 253,
    MyCSS_PROPERTY_TYPE_TEXT_DECORATION_COLOR = 254,
    MyCSS_PROPERTY_TYPE_TEXT_DECORATION_LINE = 255,
    MyCSS_PROPERTY_TYPE_TEXT_DECORATION_SKIP = 256,
    MyCSS_PROPERTY_TYPE_TEXT_DECORATION_STYLE = 257,
    MyCSS_PROPERTY_TYPE_TEXT_EMPHASIS = 258,
    MyCSS_PROPERTY_TYPE_TEXT_EMPHASIS_COLOR = 259,
    MyCSS_PROPERTY_TYPE_TEXT_EMPHASIS_POSITION = 260,
    MyCSS_PROPERTY_TYPE_TEXT_EMPHASIS_STYLE = 261,
    MyCSS_PROPERTY_TYPE_TEXT_INDENT = 262,
    MyCSS_PROPERTY_TYPE_TEXT_JUSTIFY = 263,
    MyCSS_PROPERTY_TYPE_TEXT_ORIENTATION = 264,
    MyCSS_PROPERTY_TYPE_TEXT_OVERFLOW = 265,
    MyCSS_PROPERTY_TYPE_TEXT_RENDERING = 266,
    MyCSS_PROPERTY_TYPE_TEXT_SHADOW = 267,
    MyCSS_PROPERTY_TYPE_TEXT_SIZE_ADJUST = 268,
    MyCSS_PROPERTY_TYPE_TEXT_TRANSFORM = 269,
    MyCSS_PROPERTY_TYPE_TEXT_UNDERLINE_POSITION = 270,
    MyCSS_PROPERTY_TYPE_TOP = 271,
    MyCSS_PROPERTY_TYPE_TOUCH_ACTION = 272,
    MyCSS_PROPERTY_TYPE_TRANSFORM = 273,
    MyCSS_PROPERTY_TYPE_TRANSFORM_BOX = 274,
    MyCSS_PROPERTY_TYPE_TRANSFORM_ORIGIN = 275,
    MyCSS_PROPERTY_TYPE_TRANSFORM_STYLE = 276,
    MyCSS_PROPERTY_TYPE_TRANSITION = 277,
    MyCSS_PROPERTY_TYPE_TRANSITION_DELAY = 278,
    MyCSS_PROPERTY_TYPE_TRANSITION_DURATION = 279,
    MyCSS_PROPERTY_TYPE_TRANSITION_PROPERTY = 280,
    MyCSS_PROPERTY_TYPE_TRANSITION_TIMING_FUNCTION = 281,
    MyCSS_PROPERTY_TYPE_UNICODE_BIDI = 282,
    MyCSS_PROPERTY_TYPE_USER_SELECT = 283,
    MyCSS_PROPERTY_TYPE_VERTICAL_ALIGN = 284,
    MyCSS_PROPERTY_TYPE_VISIBILITY = 285,
    MyCSS_PROPERTY_TYPE_VOICE_BALANCE = 286,
    MyCSS_PROPERTY_TYPE_VOICE_DURATION = 287,
    MyCSS_PROPERTY_TYPE_VOICE_FAMILY = 288,
    MyCSS_PROPERTY_TYPE_VOICE_PITCH = 289,
    MyCSS_PROPERTY_TYPE_VOICE_RANGE = 290,
    MyCSS_PROPERTY_TYPE_VOICE_RATE = 291,
    MyCSS_PROPERTY_TYPE_VOICE_STRESS = 292,
    MyCSS_PROPERTY_TYPE_VOICE_VOLUME = 293,
    MyCSS_PROPERTY_TYPE_WHITE_SPACE = 294,
    MyCSS_PROPERTY_TYPE_WIDOWS = 295,
    MyCSS_PROPERTY_TYPE_WIDTH = 296,
    MyCSS_PROPERTY_TYPE_WILL_CHANGE = 297,
    MyCSS_PROPERTY_TYPE_WORD_BREAK = 298,
    MyCSS_PROPERTY_TYPE_WORD_SPACING = 299,
    MyCSS_PROPERTY_TYPE_WORD_WRAP = 300,
    MyCSS_PROPERTY_TYPE_WRAP_FLOW = 301,
    MyCSS_PROPERTY_TYPE_WRAP_THROUGH = 302,
    MyCSS_PROPERTY_TYPE_WRITING_MODE = 303,
    MyCSS_PROPERTY_TYPE_Z_INDEX = 304,
    MyCSS_PROPERTY_TYPE_LAST_ENTRY = 305,
}
pub use self::mycss_property_type as mycss_property_type_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_declaration_entry {
    pub type_: mycss_property_type_t,
    pub value_type: ::std::os::raw::c_uint,
    pub value: *mut ::std::os::raw::c_void,
    pub is_important: bool,
    pub flags: mycss_declaration_flags_t,
    pub next: *mut mycss_declaration_entry_t,
    pub prev: *mut mycss_declaration_entry_t,
}
#[test]
fn bindgen_test_layout_mycss_declaration_entry() {
    assert_eq!(::std::mem::size_of::<mycss_declaration_entry>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( mycss_declaration_entry ) ));
    assert_eq! (::std::mem::align_of::<mycss_declaration_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_declaration_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . value_type
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( value_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) .
                is_important as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( is_important ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . flags as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . next as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration_entry ) ) . prev as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration_entry
                ) , "::" , stringify ! ( prev ) ));
}
impl Clone for mycss_declaration_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_declaration_entry_t = mycss_declaration_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_declaration {
    pub ref_entry: *mut mycss_entry_t,
    pub entry: *mut *mut mycss_declaration_entry_t,
    pub entry_last: *mut mycss_declaration_entry_t,
    pub stack: *mut mycss_stack_t,
    pub ending_token: mycss_token_type_t,
    pub mcobject_entries: *mut mcobject_t,
    pub mcobject_list: *mut mcobject_t,
}
#[test]
fn bindgen_test_layout_mycss_declaration() {
    assert_eq!(::std::mem::size_of::<mycss_declaration>() , 56usize , concat !
               ( "Size of: " , stringify ! ( mycss_declaration ) ));
    assert_eq! (::std::mem::align_of::<mycss_declaration>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mycss_declaration ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . ref_entry as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( ref_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . entry_last as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( entry_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . stack as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . ending_token as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( ending_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . mcobject_entries
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( mcobject_entries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_declaration ) ) . mcobject_list as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_declaration ) ,
                "::" , stringify ! ( mcobject_list ) ));
}
impl Clone for mycss_declaration {
    fn clone(&self) -> Self { *self }
}
pub type mycss_declaration_t = mycss_declaration;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_declaration_flags {
    MyCSS_DECLARATION_FLAGS_UNDEF = 0,
    MyCSS_DECLARATION_FLAGS_BAD = 1,
    MyCSS_DECLARATION_FLAGS_READ_ONLY = 2,
}
pub use self::mycss_declaration_flags as mycss_declaration_flags_t;
pub type mycss_callback_selector_done_f =
    ::std::option::Option<unsafe extern "C" fn(selectors:
                                                   *mut mycss_selectors_t,
                                               selector:
                                                   *mut mycss_selectors_entry_t)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_selectors_combinator {
    MyCSS_SELECTORS_COMBINATOR_UNDEF = 0,
    MyCSS_SELECTORS_COMBINATOR_DESCENDANT = 1,
    MyCSS_SELECTORS_COMBINATOR_CHILD = 2,
    MyCSS_SELECTORS_COMBINATOR_NEXT_SIBLING = 3,
    MyCSS_SELECTORS_COMBINATOR_FOLLOWING_SIBLING = 4,
    MyCSS_SELECTORS_COMBINATOR_COLUMN = 5,
    MyCSS_SELECTORS_COMBINATOR_LAST_ENTRY = 6,
}
pub use self::mycss_selectors_combinator as mycss_selectors_combinator_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_selectors_flags {
    MyCSS_SELECTORS_FLAGS_UNDEF = 0,
    MyCSS_SELECTORS_FLAGS_SELECTOR_BAD = 1,
}
pub use self::mycss_selectors_flags as mycss_selectors_flags_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_selectors_type {
    MyCSS_SELECTORS_TYPE_UNDEF = 0,
    MyCSS_SELECTORS_TYPE_ELEMENT = 1,
    MyCSS_SELECTORS_TYPE_ID = 2,
    MyCSS_SELECTORS_TYPE_CLASS = 3,
    MyCSS_SELECTORS_TYPE_ATTRIBUTE = 4,
    MyCSS_SELECTORS_TYPE_PSEUDO_CLASS_FUNCTION = 5,
    MyCSS_SELECTORS_TYPE_PSEUDO_CLASS = 6,
    MyCSS_SELECTORS_TYPE_PSEUDO_ELEMENT_FUNCTION = 7,
    MyCSS_SELECTORS_TYPE_PSEUDO_ELEMENT = 8,
    MyCSS_SELECTORS_TYPE_LAST_ENTRY = 9,
}
pub use self::mycss_selectors_type as mycss_selectors_type_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_media {
    pub error: mystatus_t,
}
#[test]
fn bindgen_test_layout_mycss_media() {
    assert_eq!(::std::mem::size_of::<mycss_media>() , 4usize , concat ! (
               "Size of: " , stringify ! ( mycss_media ) ));
    assert_eq! (::std::mem::align_of::<mycss_media>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mycss_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_media ) ) . error as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_media ) , "::" ,
                stringify ! ( error ) ));
}
impl Clone for mycss_media {
    fn clone(&self) -> Self { *self }
}
pub type mycss_media_t = mycss_media;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_entry_parser_list_entry {
    pub parser: mycss_parser_token_f,
    pub parser_switch: mycss_parser_token_f,
    pub ending_token: mycss_token_type_t,
    pub is_local: bool,
}
#[test]
fn bindgen_test_layout_mycss_entry_parser_list_entry() {
    assert_eq!(::std::mem::size_of::<mycss_entry_parser_list_entry>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( mycss_entry_parser_list_entry ) ));
    assert_eq! (::std::mem::align_of::<mycss_entry_parser_list_entry>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( mycss_entry_parser_list_entry
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list_entry ) ) .
                parser as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_entry_parser_list_entry ) , "::" , stringify ! ( parser
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list_entry ) ) .
                parser_switch as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_entry_parser_list_entry ) , "::" , stringify ! (
                parser_switch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list_entry ) ) .
                ending_token as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_entry_parser_list_entry ) , "::" , stringify ! (
                ending_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list_entry ) ) .
                is_local as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                mycss_entry_parser_list_entry ) , "::" , stringify ! (
                is_local ) ));
}
impl Clone for mycss_entry_parser_list_entry {
    fn clone(&self) -> Self { *self }
}
pub type mycss_entry_parser_list_entry_t = mycss_entry_parser_list_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycss_entry_parser_list {
    pub list: *mut mycss_entry_parser_list_entry_t,
    pub size: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_mycss_entry_parser_list() {
    assert_eq!(::std::mem::size_of::<mycss_entry_parser_list>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( mycss_entry_parser_list ) ));
    assert_eq! (::std::mem::align_of::<mycss_entry_parser_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycss_entry_parser_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list ) ) . list as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry_parser_list
                ) , "::" , stringify ! ( list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry_parser_list
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycss_entry_parser_list ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycss_entry_parser_list
                ) , "::" , stringify ! ( length ) ));
}
impl Clone for mycss_entry_parser_list {
    fn clone(&self) -> Self { *self }
}
pub type mycss_entry_parser_list_t = mycss_entry_parser_list;
extern "C" {
    pub fn mycss_entry_create() -> *mut mycss_entry_t;
}
extern "C" {
    pub fn mycss_entry_init(mycss: *mut mycss_t, entry: *mut mycss_entry_t)
     -> mystatus_t;
}
extern "C" {
    pub fn mycss_entry_clean(entry: *mut mycss_entry_t) -> mystatus_t;
}
extern "C" {
    pub fn mycss_entry_clean_all(entry: *mut mycss_entry_t) -> mystatus_t;
}
extern "C" {
    pub fn mycss_entry_destroy(entry: *mut mycss_entry_t, self_destroy: bool)
     -> *mut mycss_entry_t;
}
extern "C" {
    pub fn mycss_entry_end(entry: *mut mycss_entry_t);
}
extern "C" {
    pub fn mycss_entry_selectors(entry: *mut mycss_entry_t)
     -> *mut mycss_selectors_t;
}
extern "C" {
    pub fn mycss_entry_token_ready_callback(entry: *mut mycss_entry_t,
                                            callback_f:
                                                mycss_token_ready_callback_f)
     -> mycss_token_ready_callback_f;
}
extern "C" {
    pub fn mycss_entry_token_count(entry: *mut mycss_entry_t) -> usize;
}
extern "C" {
    pub fn mycss_entry_incoming_buffer_current(entry: *mut mycss_entry_t)
     -> *mut mycore_incoming_buffer_t;
}
extern "C" {
    pub fn mycss_entry_incoming_buffer_first(entry: *mut mycss_entry_t)
     -> *mut mycore_incoming_buffer_t;
}
extern "C" {
    pub fn mycss_entry_string_create_and_init(entry: *mut mycss_entry_t,
                                              string_size: usize)
     -> *mut mycore_string_t;
}
extern "C" {
    pub fn mycss_entry_stylesheet(entry: *mut mycss_entry_t)
     -> *mut mycss_stylesheet_t;
}
extern "C" {
    pub fn mycss_entry_current_selectors_list(entry: *mut mycss_entry_t)
     -> *mut mycss_selectors_list_t;
}
extern "C" {
    pub fn mycss_entry_parser_set(entry: *mut mycss_entry_t,
                                  parser: mycss_parser_token_f);
}
extern "C" {
    pub fn mycss_entry_parser_switch_set(entry: *mut mycss_entry_t,
                                         parser_switch: mycss_parser_token_f);
}
extern "C" {
    pub fn mycss_entry_parser_original_set(entry: *mut mycss_entry_t,
                                           parser_original:
                                               mycss_parser_token_f);
}
extern "C" {
    pub fn mycss_entry_parser_list_create_and_init(size: usize)
     -> *mut mycss_entry_parser_list_t;
}
extern "C" {
    pub fn mycss_entry_parser_list_clean(parser_list:
                                             *mut mycss_entry_parser_list_t);
}
extern "C" {
    pub fn mycss_entry_parser_list_destroy(parser_list:
                                               *mut mycss_entry_parser_list_t,
                                           self_destroy: bool)
     -> *mut mycss_entry_parser_list_t;
}
extern "C" {
    pub fn mycss_entry_parser_list_push(entry: *mut mycss_entry_t,
                                        parser_func: mycss_parser_token_f,
                                        parser_switch: mycss_parser_token_f,
                                        ending_token: mycss_token_type_t,
                                        is_local: bool) -> mystatus_t;
}
extern "C" {
    pub fn mycss_entry_parser_list_pop(entry: *mut mycss_entry_t);
}
extern "C" {
    pub fn mycss_entry_parser_list_length(entry: *mut mycss_entry_t) -> usize;
}
extern "C" {
    pub fn mycss_entry_parser_list_current_ending_token_type(entry:
                                                                 *mut mycss_entry_t)
     -> mycss_token_type_t;
}
extern "C" {
    pub fn mycss_entry_parser_list_current_parser(entry: *mut mycss_entry_t)
     -> mycss_parser_token_f;
}
extern "C" {
    pub fn mycss_entry_parser_list_current_parser_switch(entry:
                                                             *mut mycss_entry_t)
     -> mycss_parser_token_f;
}
extern "C" {
    pub fn mycss_entry_parser_list_current_is_local(entry: *mut mycss_entry_t)
     -> bool;
}
