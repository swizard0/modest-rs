/* automatically generated by rust-bindgen */

pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type mystatus_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_string {
    pub data: *mut ::std::os::raw::c_char,
    pub size: usize,
    pub length: usize,
    pub mchar: *mut mchar_async_t,
    pub node_idx: usize,
}
#[test]
fn bindgen_test_layout_mycore_string() {
    assert_eq!(::std::mem::size_of::<mycore_string>() , 40usize , concat ! (
               "Size of: " , stringify ! ( mycore_string ) ));
    assert_eq! (::std::mem::align_of::<mycore_string>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mycore_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . length as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . mchar as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( mchar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_string ) ) . node_idx as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_string ) , "::"
                , stringify ! ( node_idx ) ));
}
impl Clone for mycore_string {
    fn clone(&self) -> Self { *self }
}
pub type mycore_string_t = mycore_string;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mycore_incoming_buffer {
    pub data: *const ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub offset: usize,
    pub prev: *mut mycore_incoming_buffer,
    pub next: *mut mycore_incoming_buffer,
}
#[test]
fn bindgen_test_layout_mycore_incoming_buffer() {
    assert_eq!(::std::mem::size_of::<mycore_incoming_buffer>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( mycore_incoming_buffer )
               ));
    assert_eq! (::std::mem::align_of::<mycore_incoming_buffer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mycore_incoming_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . length as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . prev as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mycore_incoming_buffer ) ) . next as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mycore_incoming_buffer
                ) , "::" , stringify ! ( next ) ));
}
impl Clone for mycore_incoming_buffer {
    fn clone(&self) -> Self { *self }
}
pub type mycore_incoming_buffer_t = mycore_incoming_buffer;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mcsync {
    pub spinlock: *mut ::std::os::raw::c_int,
    pub mutex: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mcsync() {
    assert_eq!(::std::mem::size_of::<mcsync>() , 16usize , concat ! (
               "Size of: " , stringify ! ( mcsync ) ));
    assert_eq! (::std::mem::align_of::<mcsync>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mcsync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . spinlock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( spinlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mcsync ) ) . mutex as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mcsync ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for mcsync {
    fn clone(&self) -> Self { *self }
}
pub type mcsync_t = mcsync;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_node {
    pub chunk: *mut mchar_async_chunk_t,
    pub cache: mchar_async_cache_t,
}
#[test]
fn bindgen_test_layout_mchar_async_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_node>() , 72usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_node ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_node>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( mchar_async_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . chunk as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_node ) ) . cache as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_node ) ,
                "::" , stringify ! ( cache ) ));
}
impl Clone for mchar_async_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_node_t = mchar_async_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache_node {
    pub value: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub left: usize,
    pub right: usize,
    pub parent: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache_node() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache_node>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( mchar_async_cache_node )
               ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache_node>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mchar_async_cache_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . value as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . left as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( left ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . right as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( right ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache_node ) ) . parent as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache_node
                ) , "::" , stringify ! ( parent ) ));
}
impl Clone for mchar_async_cache_node {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_node_t = mchar_async_cache_node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_chunk {
    pub begin: *mut ::std::os::raw::c_char,
    pub length: usize,
    pub size: usize,
    pub next: *mut mchar_async_chunk,
    pub prev: *mut mchar_async_chunk,
}
#[test]
fn bindgen_test_layout_mchar_async_chunk() {
    assert_eq!(::std::mem::size_of::<mchar_async_chunk>() , 40usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_chunk>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . begin as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( begin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . length as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . size as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . next as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_chunk ) ) . prev as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_chunk ) ,
                "::" , stringify ! ( prev ) ));
}
impl Clone for mchar_async_chunk {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_chunk_t = mchar_async_chunk;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async_cache {
    pub nodes: *mut mchar_async_cache_node_t,
    pub nodes_size: usize,
    pub nodes_length: usize,
    pub nodes_root: usize,
    pub count: usize,
    pub index: *mut usize,
    pub index_length: usize,
    pub index_size: usize,
}
#[test]
fn bindgen_test_layout_mchar_async_cache() {
    assert_eq!(::std::mem::size_of::<mchar_async_cache>() , 64usize , concat !
               ( "Size of: " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (::std::mem::align_of::<mchar_async_cache>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mchar_async_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . nodes_root as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( nodes_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . count as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async_cache ) ) . index_size as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async_cache ) ,
                "::" , stringify ! ( index_size ) ));
}
impl Clone for mchar_async_cache {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_cache_t = mchar_async_cache;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mchar_async {
    pub origin_size: usize,
    pub chunks: *mut *mut mchar_async_chunk_t,
    pub chunks_pos_size: usize,
    pub chunks_pos_length: usize,
    pub chunks_size: usize,
    pub chunks_length: usize,
    pub chunk_cache: mchar_async_cache_t,
    pub nodes: *mut mchar_async_node_t,
    pub nodes_length: usize,
    pub nodes_size: usize,
    pub nodes_cache: *mut usize,
    pub nodes_cache_length: usize,
    pub nodes_cache_size: usize,
    pub mcsync: *mut mcsync_t,
}
#[test]
fn bindgen_test_layout_mchar_async() {
    assert_eq!(::std::mem::size_of::<mchar_async>() , 168usize , concat ! (
               "Size of: " , stringify ! ( mchar_async ) ));
    assert_eq! (::std::mem::align_of::<mchar_async>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mchar_async ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . origin_size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( origin_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_size as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_pos_length as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_pos_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunks_length as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunks_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . chunk_cache as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( chunk_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_length as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_size as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_length as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . nodes_cache_size as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( nodes_cache_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mchar_async ) ) . mcsync as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( mchar_async ) , "::" ,
                stringify ! ( mcsync ) ));
}
impl Clone for mchar_async {
    fn clone(&self) -> Self { *self }
}
pub type mchar_async_t = mchar_async;
pub const myencoding_list_MyENCODING_UTF_8: myencoding_list =
    myencoding_list::MyENCODING_DEFAULT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum myencoding_list {
    MyENCODING_DEFAULT = 0,
    MyENCODING_NOT_DETERMINED = 2,
    MyENCODING_UTF_16LE = 4,
    MyENCODING_UTF_16BE = 5,
    MyENCODING_X_USER_DEFINED = 6,
    MyENCODING_BIG5 = 7,
    MyENCODING_EUC_JP = 8,
    MyENCODING_EUC_KR = 9,
    MyENCODING_GB18030 = 10,
    MyENCODING_GBK = 11,
    MyENCODING_IBM866 = 12,
    MyENCODING_ISO_2022_JP = 13,
    MyENCODING_ISO_8859_10 = 14,
    MyENCODING_ISO_8859_13 = 15,
    MyENCODING_ISO_8859_14 = 16,
    MyENCODING_ISO_8859_15 = 17,
    MyENCODING_ISO_8859_16 = 18,
    MyENCODING_ISO_8859_2 = 19,
    MyENCODING_ISO_8859_3 = 20,
    MyENCODING_ISO_8859_4 = 21,
    MyENCODING_ISO_8859_5 = 22,
    MyENCODING_ISO_8859_6 = 23,
    MyENCODING_ISO_8859_7 = 24,
    MyENCODING_ISO_8859_8 = 25,
    MyENCODING_ISO_8859_8_I = 26,
    MyENCODING_KOI8_R = 27,
    MyENCODING_KOI8_U = 28,
    MyENCODING_MACINTOSH = 29,
    MyENCODING_SHIFT_JIS = 30,
    MyENCODING_WINDOWS_1250 = 31,
    MyENCODING_WINDOWS_1251 = 32,
    MyENCODING_WINDOWS_1252 = 33,
    MyENCODING_WINDOWS_1253 = 34,
    MyENCODING_WINDOWS_1254 = 35,
    MyENCODING_WINDOWS_1255 = 36,
    MyENCODING_WINDOWS_1256 = 37,
    MyENCODING_WINDOWS_1257 = 38,
    MyENCODING_WINDOWS_1258 = 39,
    MyENCODING_WINDOWS_874 = 40,
    MyENCODING_X_MAC_CYRILLIC = 41,
    MyENCODING_LAST_ENTRY = 42,
}
pub use self::myencoding_list as myencoding_t;
#[repr(u32)]
/// @struct mycss statuses
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_status {
    MyCSS_STATUS_OK = 0,
    MyCSS_STATUS_ERROR_MEMORY_ALLOCATION = 65537,
    MyCSS_STATUS_ERROR_TOKENIZER_STATE_ALLOCATION = 65568,
    MyCSS_STATUS_ERROR_TOKENIZER_INCOMING_BUFFER_ADD = 65569,
    MyCSS_STATUS_ERROR_TOKENIZER_TOKEN_ALLOCATION = 65570,
    MyCSS_STATUS_ERROR_INCOMING_BUFFER_INIT = 65584,
    MyCSS_STATUS_ERROR_ENTRY_INCOMING_BUFFER_CREATE = 65593,
    MyCSS_STATUS_ERROR_ENTRY_INCOMING_BUFFER_INIT = 65600,
    MyCSS_STATUS_ERROR_ENTRY_TOKEN_INCOMING_BUFFER_INIT = 65601,
    MyCSS_STATUS_ERROR_ENTRY_TOKEN_NODE_ADD = 65602,
    MyCSS_STATUS_ERROR_SELECTORS_CREATE = 65792,
    MyCSS_STATUS_ERROR_SELECTORS_ENTRIES_CREATE = 65793,
    MyCSS_STATUS_ERROR_SELECTORS_ENTRIES_INIT = 65794,
    MyCSS_STATUS_ERROR_SELECTORS_ENTRIES_NODE_ADD = 65795,
    MyCSS_STATUS_ERROR_SELECTORS_LIST_CREATE = 65796,
    MyCSS_STATUS_ERROR_SELECTORS_LIST_INIT = 65797,
    MyCSS_STATUS_ERROR_SELECTORS_LIST_ADD_NODE = 65798,
    MyCSS_STATUS_ERROR_NAMESPACE_CREATE = 66048,
    MyCSS_STATUS_ERROR_NAMESPACE_INIT = 66049,
    MyCSS_STATUS_ERROR_NAMESPACE_ENTRIES_CREATE = 66050,
    MyCSS_STATUS_ERROR_NAMESPACE_ENTRIES_INIT = 66051,
    MyCSS_STATUS_ERROR_NAMESPACE_NODE_ADD = 66052,
    MyCSS_STATUS_ERROR_MEDIA_CREATE = 66564,
    MyCSS_STATUS_ERROR_STRING_CREATE = 66817,
    MyCSS_STATUS_ERROR_STRING_INIT = 66818,
    MyCSS_STATUS_ERROR_STRING_NODE_INIT = 66819,
    MyCSS_STATUS_ERROR_AN_PLUS_B_CREATE = 67072,
    MyCSS_STATUS_ERROR_AN_PLUS_B_INIT = 67073,
    MyCSS_STATUS_ERROR_DECLARATION_CREATE = 67328,
    MyCSS_STATUS_ERROR_DECLARATION_INIT = 67329,
    MyCSS_STATUS_ERROR_DECLARATION_ENTRY_CREATE = 67330,
    MyCSS_STATUS_ERROR_DECLARATION_ENTRY_INIT = 67331,
    MyCSS_STATUS_ERROR_PARSER_LIST_CREATE = 67584,
}
pub use self::mycss_status as mycss_status_t;
#[repr(u32)]
/// Tokenizer Token types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum mycss_token_type {
    MyCSS_TOKEN_TYPE_UNDEF = 0,
    MyCSS_TOKEN_TYPE_WHITESPACE = 1,
    MyCSS_TOKEN_TYPE_IDENT = 2,
    MyCSS_TOKEN_TYPE_FUNCTION = 3,
    MyCSS_TOKEN_TYPE_AT_KEYWORD = 4,
    MyCSS_TOKEN_TYPE_HASH = 5,
    MyCSS_TOKEN_TYPE_STRING = 6,
    MyCSS_TOKEN_TYPE_URL = 7,
    MyCSS_TOKEN_TYPE_NUMBER = 8,
    MyCSS_TOKEN_TYPE_DIMENSION = 9,
    MyCSS_TOKEN_TYPE_PERCENTAGE = 10,
    MyCSS_TOKEN_TYPE_INCLUDE_MATCH = 11,
    MyCSS_TOKEN_TYPE_DASH_MATCH = 12,
    MyCSS_TOKEN_TYPE_PREFIX_MATCH = 13,
    MyCSS_TOKEN_TYPE_SUFFIX_MATCH = 14,
    MyCSS_TOKEN_TYPE_SUBSTRING_MATCH = 15,
    MyCSS_TOKEN_TYPE_COLUMN = 16,
    MyCSS_TOKEN_TYPE_CDO = 17,
    MyCSS_TOKEN_TYPE_CDC = 18,
    MyCSS_TOKEN_TYPE_BAD_STRING = 19,
    MyCSS_TOKEN_TYPE_DELIM = 20,
    MyCSS_TOKEN_TYPE_LEFT_PARENTHESIS = 21,
    MyCSS_TOKEN_TYPE_RIGHT_PARENTHESIS = 22,
    MyCSS_TOKEN_TYPE_COMMA = 23,
    MyCSS_TOKEN_TYPE_COLON = 24,
    MyCSS_TOKEN_TYPE_SEMICOLON = 25,
    MyCSS_TOKEN_TYPE_LEFT_SQUARE_BRACKET = 26,
    MyCSS_TOKEN_TYPE_RIGHT_SQUARE_BRACKET = 27,
    MyCSS_TOKEN_TYPE_LEFT_CURLY_BRACKET = 28,
    MyCSS_TOKEN_TYPE_RIGHT_CURLY_BRACKET = 29,
    MyCSS_TOKEN_TYPE_BAD_URL = 30,
    MyCSS_TOKEN_TYPE_COMMENT = 31,
    MyCSS_TOKEN_TYPE_UNICODE_RANGE = 32,
    MyCSS_TOKEN_TYPE_EOF = 33,
    MyCSS_TOKEN_TYPE_LAST_ENTRY = 34,
}
pub use self::mycss_token_type as mycss_token_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mycss {
    _unused: [u8; 0],
}
/// @struct mycss_t MyCSS
///
/// Basic structure. Create once for using many times.
pub type mycss_t = mycss;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mycss_entry {
    _unused: [u8; 0],
}
/// @struct mycss_entry_t MyCSS_ENTRY
///
/// Secondary structure. Create once for using many times.
pub type mycss_entry_t = mycss_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mycss_token {
    _unused: [u8; 0],
}
/// @struct mycss_token_t MyCSS_TOKEN
///
/// Tokenizer data structure.
pub type mycss_token_t = mycss_token;
/// @struct mycss_token_done_callback_f
///
/// Callback for token is ready
pub type mycss_token_ready_callback_f =
    ::std::option::Option<unsafe extern "C" fn(entry: *mut mycss_entry_t,
                                               token: *mut mycss_token_t)
                              -> *mut mycss_token_t>;
extern "C" {
    /// Create a MyCSS structure
///
/// @return mycss_t* if successful, otherwise an NULL value.
    pub fn mycss_create() -> *mut mycss_t;
}
extern "C" {
    /// Allocating and Initialization resources for a MyCSS structure
///
/// @param[in] mycss_t*
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status value.
    pub fn mycss_init(mycss: *mut mycss_t) -> mystatus_t;
}
extern "C" {
    /// Destroy of a MyCSS structure
///
/// @param[in] mycss_t*
/// @param[in] call free() function for mycss_t* object? true or false
///
/// @return NULL if successful, otherwise an MyCSS structure.
    pub fn mycss_destroy(mycss: *mut mycss_t, self_destroy: bool)
     -> *mut mycss_t;
}
extern "C" {
    /// Parsing CSS
///
/// @param[in] previously created structure mycss_entry_t*
/// @param[in] Now is not working! Coming Soon. Input character encoding; Default: MyENCODING_UTF_8 or MyENCODING_DEFAULT or 0
/// @param[in] CSS data
/// @param[in] CSS data size
///
/// All input character encoding decode to utf-8
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status
    pub fn mycss_parse(entry: *mut mycss_entry_t, encoding: myencoding_t,
                       css: *const ::std::os::raw::c_char, css_size: usize)
     -> mystatus_t;
}
extern "C" {
    /// Parsing CSS chunk. For End Parsing call mycss_parse_chunk_end function
///
/// @param[in] previously created structure mycss_entry_t*
/// @param[in] CSS data
/// @param[in] CSS data size
///
/// All input character encoding decode to utf-8
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status
    pub fn mycss_parse_chunk(entry: *mut mycss_entry_t,
                             css: *const ::std::os::raw::c_char,
                             css_size: usize) -> mystatus_t;
}
extern "C" {
    /// End of parsing CSS chunks
///
/// @param[in] mycss_entry_t*
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status
    pub fn mycss_parse_chunk_end(entry: *mut mycss_entry_t) -> mystatus_t;
}
extern "C" {
    /// Create a MyCSS_ENTRY structure
///
/// @return mycss_entry_t* if successful, otherwise an NULL value.
    pub fn mycss_entry_create() -> *mut mycss_entry_t;
}
extern "C" {
    /// Allocating and Initialization resources for a MyCSS_ENTRY structure
///
/// @param[in] mycss_t*
/// @param[in] mycss_entry_t*
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status value.
    pub fn mycss_entry_init(mycss: *mut mycss_t, entry: *mut mycss_entry_t)
     -> mystatus_t;
}
extern "C" {
    /// Clear all structures
///
/// @param[in] mycss_entry_t*
///
/// @return MyCSS_STATUS_OK if successful, otherwise an error status value.
    pub fn mycss_entry_clean_all(entry: *mut mycss_entry_t) -> mystatus_t;
}
extern "C" {
    /// Destroy of a MyCSS_ENTRY structure
///
/// @param[in] mycss_entry_t*
/// @param[in] call free() function for mycss_entry_t* object? true or false
///
/// @return NULL if successful, otherwise an MyCSS_ENTRY structure.
    pub fn mycss_entry_destroy(entry: *mut mycss_entry_t, self_destroy: bool)
     -> *mut mycss_entry_t;
}
extern "C" {
    /// Set or Get current callback function for token is ready
///
/// @param[in] mycss_entry_t*
/// @param[in] mycss_token_ready_callback_f
/// function which will be returned when the token is ready
/// or NULL for only return current function
///
/// @example_function
/// mycss_token_t * your_name_callback(mycss_entry_t* entry, mycss_token_t* token) {
/// return token;
/// }
///
/// @example See tokenizer_high_level.c in examples directory
///
/// @return mycss_token_ready_callback_f structure
    pub fn mycss_entry_token_ready_callback(entry: *mut mycss_entry_t,
                                            callback_f:
                                                mycss_token_ready_callback_f)
     -> mycss_token_ready_callback_f;
}
extern "C" {
    /// Get tokens count
///
/// @param[in] mycss_entry_t*
///
/// @return count of token
    pub fn mycss_entry_token_count(entry: *mut mycss_entry_t) -> usize;
}
extern "C" {
    /// Get current Incoming Buffer
/// See MyHTML_INCOMING in https://github.com/lexborisov/myhtml
///
/// @param[in] mycss_entry_t*
///
/// @return mycore_incoming_buffer_t* if successful, otherwise an NULL value.
    pub fn mycss_entry_incoming_buffer_current(entry: *mut mycss_entry_t)
     -> *mut mycore_incoming_buffer_t;
}
extern "C" {
    /// Get first Incoming Buffer from list
/// See MyHTML_INCOMING in https://github.com/lexborisov/myhtml
///
/// @param[in] mycss_entry_t*
///
/// @return mycore_incoming_buffer_t* if successful, otherwise an NULL value.
    pub fn mycss_entry_incoming_buffer_first(entry: *mut mycss_entry_t)
     -> *mut mycore_incoming_buffer_t;
}
extern "C" {
    /// Get begin position of Token
///
/// @param[in] mycss_token_t*
///
/// @return size_t, begin position for token
    pub fn mycss_token_begin(token: *mut mycss_token_t) -> usize;
}
extern "C" {
    /// Get length of Token
///
/// @param[in] mycss_token_t*
///
/// @return size_t, length of token
    pub fn mycss_token_length(token: *mut mycss_token_t) -> usize;
}
extern "C" {
    /// Get begin position and length for Token
///
/// @param[in] mycss_token_t*
/// @param[out] size_t*, optional, token length
///
/// @return size_t, begin position for token
    pub fn mycss_token_position(token: *mut mycss_token_t,
                                return_length: *mut usize) -> usize;
}
extern "C" {
    /// Get Token type
///
/// @param[in] mycss_token_t*
///
/// @return mycss_token_type_t
    pub fn mycss_token_type(token: *mut mycss_token_t) -> mycss_token_type_t;
}
extern "C" {
    /// Get Token name by Token type
///
/// @param[in] mycss_token_type_t
///
/// @return token name terminated with a null character ('\0')
    pub fn mycss_token_name_by_type(type_: mycss_token_type_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Converting raw token data (your input const char*)
/// to strict string as required by the specification
///
/// @param[in] mycss_entry_t*
/// @param[in] mycss_token_t*, token from which data will be obtained
/// @param[in] mycore_string_t*, a pointer to the row in which the data will be written
/// @param[in] initialization mycore_string_t* object
///
/// @return length of processed data
    pub fn mycss_token_data_to_string(entry: *mut mycss_entry_t,
                                      token: *mut mycss_token_t,
                                      str: *mut mycore_string_t,
                                      init_string: bool) -> usize;
}
extern "C" {
    /// Set character encoding for input stream
///
/// @param[in] mycss_entry_t*
/// @param[in] Input character encoding.
/// See https://github.com/lexborisov/myhtml/blob/master/source/myhtml/api.h
/// myencoding_t
///
    pub fn mycss_encoding_set(entry: *mut mycss_entry_t,
                              encoding: myencoding_t);
}
extern "C" {
    /// Get character encoding for current stream
///
/// @param[in] mycss_entry_t*
///
/// @return myencoding_t
    pub fn mycss_encoding_get(entry: *mut mycss_entry_t) -> myencoding_t;
}
extern "C" {
    /// Get encoding from @charset "...";
///
/// See for information:
/// https://www.w3.org/TR/css-syntax-3/#get-an-encoding
/// https://www.w3.org/TR/css-syntax-3/#charset-rule
/// myencoding_by_name in https://github.com/lexborisov/myhtml/blob/master/source/myhtml/api.h
///
/// If @charset rule is missing or encoding not found return MyENCODING_UTF_8 by default
///
/// @param[in] css data stream
/// @param[in] css data stream size
///
/// @return myencoding_t
    pub fn mycss_encoding_check_charset_rule(css:
                                                 *const ::std::os::raw::c_char,
                                             size: usize) -> myencoding_t;
}
extern "C" {
    /// Convert data to double number
///
/// @param[in]  data to convert
/// @param[in]  data size
/// @param[out] converting result
/// @param[out] is integer or float
///
/// @return length of data converting
    pub fn mycss_convert_data_to_double(data: *const ::std::os::raw::c_char,
                                        size: usize, return_num: *mut f64,
                                        is_float: *mut bool) -> usize;
}
extern "C" {
    /// Convert data to unicode range code point
/// See https://www.w3.org/TR/css-syntax-3/#unicode-range-token-diagram
/// See https://www.w3.org/TR/css-syntax-3/#consume-a-unicode-range-token
///
/// @param[in]  data to convert
/// @param[in]  data size
/// @param[out] start range converting result
/// @param[out] end range converting result
///
/// @return length of data converting
    pub fn mycss_convert_unicode_range_to_codepoint(data:
                                                        *const ::std::os::raw::c_char,
                                                    size: usize,
                                                    start: *mut usize,
                                                    end: *mut usize) -> usize;
}
extern "C" {
    /// Convert hex data to code point
///
/// @param[in]  data to convert
/// @param[in]  data size
/// @param[out] result codepoint
/// @param[in]  how much length can be consumed
///
/// @return length of data converting
    pub fn mycss_convert_hex_to_codepoint(data: *const ::std::os::raw::c_char,
                                          size: usize, codepoint: *mut usize,
                                          max_consumed:
                                              ::std::os::raw::c_uint)
     -> usize;
}
